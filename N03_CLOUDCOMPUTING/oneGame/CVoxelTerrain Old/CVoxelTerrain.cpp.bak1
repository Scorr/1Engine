

// Includes
#include "CVoxelTerrain.h"

// Static variable declares
const LongIntPosition CVoxelTerrain::boobSize = LongIntPosition( 32,32,32 ); //b-cup
const ftype CVoxelTerrain::blockSize = 2.0f;
//Perlin CVoxelTerrain::noise = Perlin( 4,4,1,0 );
Perlin CVoxelTerrain::noise = Perlin( 1,2,1,0 );

// Class definitions
CVoxelTerrain::CVoxelTerrain ( void )
	: CGameObject() , CRenderableObject()
{
	vertexCount = 0;
	faceCount = 0;
	try
	{
		//vertices = new CTerrainVertex [1048576];
		//quads = new CModelQuad [8388608];
		vertices = new CTerrainVertex [8388608];
		quads = new CModelQuad [8388608];
		//vertices = new CTerrainVertex [16777216];
		//quads = new CModelQuad		  [33554432];
	}
	catch ( bad_alloc& ba )
	{
		//MessageBox ( NULL,"FUCKING MEMORY.","FACK FACK FACK MEMORY FACK",MB_OK | MB_ICONINFORMATION );
		MessageBox ( NULL,"FUCKING MEMORY COULD NOT BE FUCKING ALLOCATION. BAD ALLOCATION TO BE FUCKING EXACT.","FACK FACK FACK MEMORY FACK",MB_OK | MB_ICONINFORMATION );
	}

	// Create VBO
	glGenBuffersARB( 1, &iVBOverts );
	glGenBuffersARB( 1, &iVBOfaces );

	glBindBufferARB(GL_ARRAY_BUFFER_ARB, iVBOverts);         // for vertex coordinates
	glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces); // for face vertex indexes

	glBufferDataARB( GL_ARRAY_BUFFER_ARB, sizeof(CTerrainVertex)*8388608, NULL, GL_STREAM_DRAW_ARB );
	glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, sizeof(CModelQuad)*8388608, NULL, GL_STREAM_DRAW_ARB );
	iVBOType = GL_STREAM_DRAW_ARB;

	// bind with 0, so, switch back to normal pointer operation
	glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
	glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);

	needUpdateOnVBO = false;
	

	if ( true )
	{
		// GENERATE NEW WORLD
		int size = 13;// 23;
		CBoob* temp_x;
		CBoob* temp_y;
		CBoob* temp_z;
		//root = GenerateBoob();
		/*LinkCube( root, GenerateBoob(), 3 );
		LinkCube( root, GenerateBoob(), 4 );
		LinkCube( root, GenerateBoob(), 5 );
		LinkCube( root, GenerateBoob(), 6 );
		LinkCube( root->left, GenerateBoob(), 3 );
		LinkCube( root->right, GenerateBoob(), 3 );
		LinkCube( root->left, GenerateBoob(), 4 );
		LinkCube( root->right, GenerateBoob(), 4 );*/
		/*temp = root;
		for ( int i = 0; i < size; i += 1 )
		{
			LinkCube( temp, GenerateBoob(), 3 );
			temp = temp->front;
		}
		temp = root;
		for ( int i = 0; i < size; i += 1 )
		{
			LinkCube( temp, GenerateBoob(), 4 );
			temp = temp->back;
		}
		
		for ( int i = 0; i <= 9*2; i += 1 )
		{
			LinkCube( temp, GenerateBoob(), 5 );
			temp = temp->front;
		}*/
		temp_x = NULL;
		temp_y = NULL;
		temp_z = GenerateBoob();
		root = temp_z;
		for ( int k = 0; k < size; k += 1 )
		{
			if ( k != 0 )
			{
				LinkCube( temp_z, GenerateBoob(), BOTTOM );
				temp_z = temp_z->bottom;
			}
			//else
			//	temp_z = root = GenerateBoob();
			for ( int j = 0; j < size; j += 1 )
			{
				if ( j != 0 )
				{
					LinkCube( temp_y, GenerateBoob(), BACK );
					temp_y = temp_y->back;
				}
				else 
					temp_y = temp_z;
				for ( int i = 0; i < size; i += 1 )
				{
					if ( i != 0 )
					{
						LinkCube( temp_x, GenerateBoob(), RIGHT );
						temp_x = temp_x->right;
					}
					else
						temp_x = temp_y;
				}
			}	
		}

		/*root = temp_z;
		for ( int k = 0; k < size/2; k += 1 )
		{
			root = temp_z->top->right->back;
		}*/
		//root = temp_z;
		for ( int k = 0; k < size/2; k += 1 )
		{
			root = root->bottom->right->back;
		}

		GenerateTerrain( root, root_position );

		// END WORLD GENERATION
	}
	else
	{
		// Load world from file.
	}

	iCubeList = glGenLists( 1 );
	iFaceList = glGenLists( 6 );
	GenerateCube();

	renderMethod = 0;

	stepNum = 0;
}

CVoxelTerrain::~CVoxelTerrain ( void )
{
	// Free VBO
	glDeleteBuffersARB( 1, &iVBOverts );
	glDeleteBuffersARB( 1, &iVBOfaces );
	// Delete the data...sorta, gotta get it working PROPER (MEM LEAK ATM) TODO
	delete [] vertices;
	delete [] quads;
	//delete root;
	FreeTerrain( root );
}
// Recursive Destructor Assistant
void CVoxelTerrain::FreeTerrain ( CBoob* pBoob )
{
	if ( pBoob != NULL )
	{
		if ( pBoob->bitinfo[7] == false )
		{
			pBoob->bitinfo[7] = true;
			
			FreeTerrain( pBoob->left );
			FreeTerrain( pBoob->right );
			FreeTerrain( pBoob->front );
			FreeTerrain( pBoob->back );
			FreeTerrain( pBoob->top );
			FreeTerrain( pBoob->bottom );

			if ( pBoob->left )
				pBoob->left->right = NULL;
			if ( pBoob->right )
				pBoob->right->left = NULL;
			if ( pBoob->top )
				pBoob->top->bottom = NULL;
			if ( pBoob->bottom )
				pBoob->bottom->top = NULL;
			if ( pBoob->front )
				pBoob->front->back = NULL;
			if ( pBoob->back )
				pBoob->back->front = NULL;

			delete pBoob;
		}
	}
}

void CVoxelTerrain::Update ( void )
{
	Matrix4x4 rotMatrix;
	rotMatrix.setRotation( CCamera::pActiveCamera->transform.rotation );
	vCameraDir = rotMatrix * Vector3d( 1,0,0 );
	vCameraPos = CCamera::pActiveCamera->transform.position;

	/*
	// Toggle render mode
	if ( CInput::keydown['Z'] )
	{
		if ( renderMethod == 0 )
			renderMethod = 1;
		else if ( renderMethod == 1 )
			renderMethod = 0;
	}
	*/
	// Switch VBO modes
	if ( CInput::keydown[VK_F12] )
	{
		if ( iVBOType == GL_STREAM_DRAW_ARB )
			iVBOType = GL_DYNAMIC_DRAW_ARB;
		else
			iVBOType = GL_STREAM_DRAW_ARB;

		// Free VBO
		glDeleteBuffersARB( 1, &iVBOverts );
		glDeleteBuffersARB( 1, &iVBOfaces );
		// Create VBO
		glGenBuffersARB( 1, &iVBOverts );
		glGenBuffersARB( 1, &iVBOfaces );

		glBindBufferARB(GL_ARRAY_BUFFER_ARB, iVBOverts);         // for vertex coordinates
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces); // for face vertex indexes

		glBufferDataARB( GL_ARRAY_BUFFER_ARB, sizeof(CTerrainVertex)*8388608, NULL, iVBOType );
		glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, sizeof(CModelQuad)*8388608, NULL, iVBOType );
		iVBOType = GL_STREAM_DRAW_ARB;

		// bind with 0, so, switch back to normal pointer operation
		glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
	}

	// Test digging
	/*BlockInfo infoes;
	if ( GetBlockInfoAtPosition( vCameraPos, infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(0,2,0), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(0,-2,0), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(2,0,0), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(-2,0,0), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(0,0,2), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}
	if ( GetBlockInfoAtPosition( vCameraPos+Vector3d(0,0,-2), infoes ) )
	{
		if ( *(infoes.pBlock) > 0 )
			needUpdateOnVBO = true;
		*(infoes.pBlock) = 0;
	}*/

	// Update the root node based on camera position
	UpdateRoot();
	
	// Reset drawn, cull
	ResetBlockDrawn ( root );
	CullTree32( root, root_position );
	//PerformOcclusion();

	if ( CInput::keydown[VK_F11] )
	{
		stepNum = 0;
	}
}

// Updates the root node based on camera position and current root position
void CVoxelTerrain::UpdateRoot ( void )
{
	// Boolean to update LOD's if root has been updated
	bool bRootUpdated = false;

	// Check if the current camera position is in bounds
	Vector3d pos = vCameraPos * ( 1.0f/64.0f );

	// Check for forward movement
	if ( pos.x > (root_position.x+1) )
	{
		if ( root->front != NULL )
		{
			root = root->front;
			root_position.x += 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}
	// Check for back movement
	if ( pos.x < root_position.x )
	{
		if ( root->back != NULL )
		{
			root = root->back;
			root_position.x -= 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}
	// Check for left movement
	if ( pos.y > (root_position.y+1) )
	{
		if ( root->left != NULL )
		{
			root = root->left;
			root_position.y += 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}
	// Check for right movement
	if ( pos.y < root_position.y )
	{
		if ( root->right != NULL )
		{
			root = root->right;
			root_position.y -= 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}
	// Check for top movement
	if ( pos.z > (root_position.z+1) )
	{
		if ( root->top != NULL )
		{
			root = root->top;
			root_position.z += 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}
	// Check for down movement
	if ( pos.z < root_position.z )
	{
		if ( root->bottom != NULL )
		{
			root = root->bottom;
			root_position.z -= 1;
			bRootUpdated = true;
		}
		//else
		//	break;
	}

	// Update the LOD's if the root has changed
	if ( bRootUpdated )
	{
		UpdateLODs ( root, 1, root_position );
	}
}

void CVoxelTerrain::ResetBlockDrawn ( CBoob * pBoob )
{
	if ( pBoob != NULL )
	{
		if (( pBoob->bitinfo[1] == true )||( pBoob->bitinfo[2] == true ))
		{
			pBoob->visible = false;
			pBoob->bitinfo[1] = false;
			pBoob->bitinfo[2] = false;
			pBoob->bitinfo[4] = false;
			ResetBlockDrawn( pBoob->front );
			ResetBlockDrawn( pBoob->back );
			ResetBlockDrawn( pBoob->left );
			ResetBlockDrawn( pBoob->right );
			ResetBlockDrawn( pBoob->bottom );
			ResetBlockDrawn( pBoob->top );
		}
	}
}

// --Looker functions for lookin--
CBoob*		CVoxelTerrain::GetBoobAtPosition ( Vector3d const& position )
{
	// Need floor( x,y,z divided by boobSize*blockSize )
	/*int posx = (int)floor( position.x/(boobSize.x*blockSize) );
	int posy = (int)floor( position.y/(boobSize.y*blockSize) );
	int posz = (int)floor( position.z/(boobSize.z*blockSize) );*/
	CBoob* result = root;
	Vector3d pos = position;
	pos.x /= (boobSize.x*blockSize);
	pos.y /= (boobSize.y*blockSize);
	pos.z /= (boobSize.z*blockSize);
	ftype dif;
	const static Vector3d offset ( 1.0f/boobSize.x, 1.0f/boobSize.y, 1.0f/boobSize.z );

	// Go forward
	if ( pos.x > root_position.x )
	{
		dif = (pos.x-root_position.x)-1+offset.x;
		for ( ftype i = 0; i < dif; i += 1 )
		{
			result = result->front;
			//if ( result == NULL )
			//	throw 
		}
	}
	else // Go backward
	{
		dif = (root_position.x-pos.x)-1+offset.x;
		for ( ftype i = 0; i < dif; i += 1 )
			result = result->back;
	}

	// Go left
	if ( pos.y > root_position.y )
	{
		dif = (pos.y-root_position.y)-1+offset.y;
		for ( ftype i = 0; i < dif; i += 1 )
			result = result->left;
	}
	else // Go right
	{
		dif = (root_position.y-pos.y)-1+offset.y;
		for ( ftype i = 0; i < dif; i += 1 )
			result = result->right;
	}

	// Go up
	if ( pos.z > root_position.z )
	{
		dif = (pos.z-root_position.z)-1+offset.z;
		for ( ftype i = 0; i < dif; i += 1 )
			result = result->top;
	}
	else // Go down
	{
		dif = (root_position.z-pos.z)-1+offset.z;
		for ( ftype i = 0; i < dif; i += 1 )
			result = result->bottom;
	}

	return result;
}
subblock16*	CVoxelTerrain::GetSubblock16AtPosition ( Vector3d const& position )
{

}
subblock8*	CVoxelTerrain::GetSubblock8AtPosition ( Vector3d const& position )
{

}
char		CVoxelTerrain::GetBlockAtPosition ( Vector3d const& position )
{

}
bool		CVoxelTerrain::GetBlockInfoAtPosition ( Vector3d const& position, BlockInfo & finalBlockInfo )
{
	// Need floor( x,y,z divided by boobSize*blockSize )
	//BlockInfo finalBlockInfo;
	CBoob* result = root;
	Vector3d pos = position;
	pos.x /= (boobSize.x*blockSize);
	pos.y /= (boobSize.y*blockSize);
	pos.z /= (boobSize.z*blockSize);
	ftype dif, i;
	ftype dummy;
	//const static Vector3d offset ( 1.0f/boobSize.x, 1.0f/boobSize.y, 1.0f/boobSize.z );
	const static Vector3d offset ( 0.0f/boobSize.x, 0.0f/boobSize.y, 0.0f/boobSize.z );
	
	/*
	// Debug output
	char szTitle[256]={0};
	sprintf( szTitle, "%lf %lf %lf\n", position.x,position.y,position.z );
	OutputDebugStringA( szTitle );
	*/

	// Get the current boob
	// Go forward
	if ( pos.x > root_position.x )
	{
		dif = (pos.x-root_position.x)-1+offset.x;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->front;
			if ( result == NULL )
				return false;
		}
	}
	else // Go backward
	{
		dif = (root_position.x-pos.x)-offset.x;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->back;
			if ( result == NULL )
				return false;
		}
	}
	// Go left
	if ( pos.y > root_position.y )
	{
		dif = (pos.y-root_position.y)-1+offset.y;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->left;
			if ( result == NULL )
				return false;
		}
	}
	else // Go right
	{
		dif = (root_position.y-pos.y)-offset.y;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->right;
			if ( result == NULL )
				return false;
		}
	}
	// Go up
	if ( pos.z > root_position.z )
	{
		dif = (pos.z-root_position.z)-1+offset.z;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->top;
			if ( result == NULL )
				return false;
		}
	}
	else // Go down
	{
		dif = (root_position.z-pos.z)-offset.z;
		for ( i = 0; i < dif; i += 1 )
		{
			result = result->bottom;
			if ( result == NULL )
				return false;
		}
	}

	// Final check
	if ( result == NULL )
		return false;
	finalBlockInfo.pBoob = result;
	// Found Boob

	// Find current subblock16
	pos.x = modf( pos.x, &dummy );
	pos.y = modf( pos.y, &dummy );
	pos.z = modf( pos.z, &dummy );
	if ( pos.x < 0 )
		pos.x += 1;
	if ( pos.y < 0 )
		pos.y += 1;
	if ( pos.z < 0 )
		pos.z += 1;

	/*
	// Debug output
	//char szTitle[256]={0};
	sprintf( szTitle, "%lf %lf %lf\n", pos.x,pos.y,pos.z );
	OutputDebugStringA( szTitle );
	*/

	pos *= 2.0f;

	finalBlockInfo.b16index = 0;
	//for ( i = 0; i < pos.x-1; i += 1 )
	if ( pos.x > 1.0f )
		finalBlockInfo.b16index += 1;
	//for ( i = 0; i < pos.y-1; i += 1 )
	if ( pos.y > 1.0f )
		finalBlockInfo.b16index += 2;
	//for ( i = 0; i < pos.z-1; i += 1 )
	if ( pos.z > 1.0f )
		finalBlockInfo.b16index += 4;
	finalBlockInfo.pBlock16 = &(finalBlockInfo.pBoob->data[finalBlockInfo.b16index]);
	// Found current subblock16

	// Find current subblock8
	pos.x = modf( pos.x, &dummy );
	pos.y = modf( pos.y, &dummy );
	pos.z = modf( pos.z, &dummy );

	pos *= 2.0f;

	finalBlockInfo.b8index = 0;
	//for ( i = 0; i < pos.x-1; i += 1 )
	if ( pos.x > 1.0f )
		finalBlockInfo.b8index += 1;
	//for ( i = 0; i < pos.y-1; i += 1 )
	if ( pos.y > 1.0f )
		finalBlockInfo.b8index += 2;
	//for ( i = 0; i < pos.z-1; i += 1 )
	if ( pos.z > 1.0f )
		finalBlockInfo.b8index += 4;
	finalBlockInfo.pBlock8 = &(finalBlockInfo.pBoob->data[finalBlockInfo.b16index].data[finalBlockInfo.b8index]);
	// Found current subblock8

	// Find current block
	pos.x = modf( pos.x, &dummy );
	pos.y = modf( pos.y, &dummy );
	pos.z = modf( pos.z, &dummy );

	pos *= 8.0f;

	finalBlockInfo.b1index = 0;
	for ( i = 1; i < pos.x; i += 1 )
		finalBlockInfo.b1index += 1;
	for ( i = 1; i < pos.y; i += 1 )
		finalBlockInfo.b1index += 8;
	for ( i = 1; i < pos.z; i += 1 )
		finalBlockInfo.b1index += 64;
	finalBlockInfo.block = finalBlockInfo.pBoob->data[finalBlockInfo.b16index].data[finalBlockInfo.b8index].data[finalBlockInfo.b1index];
	finalBlockInfo.pBlock = &(finalBlockInfo.pBoob->data[finalBlockInfo.b16index].data[finalBlockInfo.b8index].data[finalBlockInfo.b1index]);
	// Found current block

	//return finalBlockInfo;
	return true;
}

// PRIVATE::

void CVoxelTerrain::UpdateLODs ( CBoob* pBoob, char currentResolution, LongIntPosition const& position )
{
	if ( pBoob != NULL )
	{
		if ( pBoob->bitinfo[4] == false )
		{
			pBoob->bitinfo[4] = true;


			// Get new resolution value
			/*char newResolution = currentResolution*2;
			if ( newResolution > 8 )
			{
				newResolution = 8;
			}*/
			const static unsigned char maxRes = 4;

			unsigned char newResolution = 1;
			Vector3d vDist = Vector3d( position.x-root_position.x, position.y-root_position.y, position.z-root_position.z );
			ftype fDist = vDist.sqrMagnitude();
			for ( ftype f = 6; f < fDist; f += 6 ) //f=3 orig
			{
				newResolution *= 2;
				if ( newResolution > maxRes )
				{
					newResolution = maxRes;
					break;
				}
			}
			/*if ( newResolution > 4 )
			{
				newResolution = 4;
			}*/
			pBoob->current_resolution = newResolution;
	
			// Set the new resolutions
			/*if ( pBoob->front != NULL )
				if ( !pBoob->front->bitinfo[4] )
					pBoob->front->current_resolution = newResolution;
			if ( pBoob->back != NULL )
				if ( !pBoob->back->bitinfo[4] )
					pBoob->back->current_resolution = newResolution;
			if ( pBoob->left != NULL )
				if ( !pBoob->left->bitinfo[4] )
					pBoob->left->current_resolution = newResolution;
			if ( pBoob->right != NULL )
				if ( !pBoob->right->bitinfo[4] )
					pBoob->right->current_resolution = newResolution;
			if ( pBoob->top != NULL )
				if ( !pBoob->top->bitinfo[4] )
					pBoob->top->current_resolution = newResolution;
			if ( pBoob->bottom != NULL )
				if ( !pBoob->bottom->bitinfo[4] )
					pBoob->bottom->current_resolution = newResolution;*/

			// Call resolution set for other guys
			if ( position.x >= root_position.x )
				UpdateLODs( pBoob->front, newResolution, LongIntPosition( position.x+1, position.y, position.z ) );
			if ( position.y >= root_position.y )
				UpdateLODs( pBoob->left, newResolution, LongIntPosition( position.x, position.y+1, position.z ) );
			if ( position.z >= root_position.z )
				UpdateLODs( pBoob->top, newResolution, LongIntPosition( position.x, position.y, position.z+1 ) );
			if ( position.x <= root_position.x )
				UpdateLODs( pBoob->back, newResolution, LongIntPosition( position.x-1, position.y, position.z ) );
			if ( position.y <= root_position.y )
				UpdateLODs( pBoob->right, newResolution, LongIntPosition( position.x, position.y-1, position.z ) );
			if ( position.z <= root_position.z )
				UpdateLODs( pBoob->bottom, newResolution, LongIntPosition( position.x, position.y, position.z-1 ) );
		}
	}
}

// Tree visibilty culling, based on frustum culling.
void CVoxelTerrain::CullTree32 ( CBoob * pBoob, LongIntPosition const& position )
{
	if ( pBoob != NULL )
	{
		if ( pBoob->bitinfo[2] == false )
		{
			// Set drawn flag
			pBoob->bitinfo[2] = true;

			char result;
			result = CCamera::pActiveCamera->SphereIsVisible(
				Vector3d(
					ftype(position.x*64+32),
					ftype(position.y*64+32),
					ftype(position.z*64+32)
					), 55 //32
				);

			// Check current boob
			if ( result == 2 )
			{
				if ( !pBoob->bitinfo[0] )
					needUpdateOnVBO = true;
				pBoob->bitinfo[0] = true;
				for ( char i = 0; i < 8; i += 1 )
				{
					pBoob->visible[i] = true;
					for ( char j = 0; j < 8; j += 1 )
					{
						pBoob->data[i].visible[j] = true;
					}
				}
			}
			else if ( result == 1 )
			{
				pBoob->bitinfo[0] = true;
				/*for ( char i = 0; i < 8; i += 1 )
				{
					if ( pBoob->visible[i] )
					{
						CullTree16( pBoob, &(pBoob->data[i]), i, position );
					}
				}*/
				for ( char i = 0; i < 8; i += 1 )
				{
					pBoob->visible[i] = true;
					for ( char j = 0; j < 8; j += 1 )
					{
						pBoob->data[i].visible[j] = true;
					}
				}
			}
			else if ( result == 0 )
			{
				if ( pBoob->bitinfo[0] )
					needUpdateOnVBO = true;
				// Boob completely invisible
				pBoob->bitinfo[0] = false;
			}

			// Cull other boobs
			CullTree32( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
			CullTree32( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
			CullTree32( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
			CullTree32( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
			CullTree32( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
			CullTree32( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		}
	}
}

void CVoxelTerrain::CullTree16 ( CBoob * pBoob, subblock16 * block, char const index, LongIntPosition const& position )
{
	// Draw current block
	for ( char i = 0; i < 8; i += 1 )
	{
		char result;
		result = CCamera::pActiveCamera->SphereIsVisible(
			Vector3d(
				ftype(position.x*64 + ((index%2))*32 + 16),
				ftype(position.y*64 + ((index/2)%2)*32 + 16),
				ftype(position.z*64 + ((index/4))*32 + 16)
				), 27 //16
			);
		if ( result == 2 )
		{
			if ( !pBoob->visible[index] )
				needUpdateOnVBO = true;
			pBoob->visible[index] = true;
			for ( char j = 0; j < 8; j += 1 )
			{
				block->visible[j] = true;
			}
		}
		else if ( result == 1 )
		{
			pBoob->visible[index] = false;
			CullTree8( pBoob, &(block->data[i]), index, i, position );
		}
		else if ( result == 0 )
		{
			if ( pBoob->visible[index] )
				needUpdateOnVBO = true;
			pBoob->visible[index] = false;
		}

		/*if ( pBoob->visible[i] )
		{
			CullTree8( pBoob, &(block->data[i]), index, i, position );
		}*/
	}
}
void CVoxelTerrain::CullTree8 ( CBoob * pBoob, subblock8 * block, char const index, char const subindex, LongIntPosition const& position )
{

}

CBoob* CVoxelTerrain::GenerateBoob ( void )
{
	bool startVisible = true;
	CBoob* pNewBoob;
	try
	{
		pNewBoob = new CBoob;
	}
	catch ( bad_alloc& ba )
	{
		//char* bull = ba.what();
		MessageBox ( NULL,"FUCKING MEMORY.","FACK FACK FACK MEMORY FACK",MB_OK | MB_ICONINFORMATION );
	}
	//CBoob* pNewBoob = new CBoob;
	pNewBoob->front = NULL;
	pNewBoob->back = NULL;
	pNewBoob->top = NULL;
	pNewBoob->bottom = NULL;
	pNewBoob->left = NULL;
	pNewBoob->right = NULL;

	pNewBoob->current_resolution = 1;

	/*for ( unsigned int i = 0; i < 32768; i += 1 )
	{
		pNewBoob->data[i] = 0;
	}*/
	pNewBoob->bitinfo[0] = startVisible; // Visible flag
	pNewBoob->bitinfo[1] = false; // AlreadyDrawn flag
	pNewBoob->bitinfo[2] = false; // AlreadyChecked flag
	pNewBoob->bitinfo[3] = false; // Generation flag
	pNewBoob->bitinfo[7] = false; // Deletion flag
	for ( char i = 0; i < 8; i += 1 )
	{
		pNewBoob->visible[i] = startVisible;
		for ( char j = 0; j < 8; j += 1 )
		{
			pNewBoob->data[i].visible[j] = startVisible;
			for ( int k = 0; k < 512; k += 1 )
			{
				pNewBoob->data[i].data[j].data[k] = 0;
			}
		}
	}

	return pNewBoob;
}

void CVoxelTerrain::GetBlockXYZ( unsigned int &x,unsigned int &y,unsigned int &z,unsigned int const& i ,unsigned int const& j ,unsigned int const& k  )
{
	x = ((i%2) * 16) + ((j%2) * 8) + (k%8);
	y = (((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8);
	z = ((i/4) * 16) + ((j/4) * 8)  + (k/64);
}

void CVoxelTerrain::GenerateTerrain ( CBoob * pBoob, LongIntPosition const& position )
{
	if (( pBoob != NULL )&&( pBoob->bitinfo[3] == false ))
	{
		// FIX THIS
		if ( position.z >= 0 )
			GenerateTerrain( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
		if ( position.x >= 0 )
			GenerateTerrain( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
		if ( position.y >= 0 )
			GenerateTerrain( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
		if ( position.z <= 0 )
			GenerateTerrain( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
		if ( position.x <= 0 )
			GenerateTerrain( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
		if ( position.y <= 0 )
			GenerateTerrain( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		pBoob->bitinfo[3] = true;

		//pBoob->current_resolution = (char)pow( 2.0, (int)((position.x+position.y+position.z)/3) );
		//pBoob->current_resolution *= 2;
		// TODO
		// TEMPORARY LoD SYS CHECK
		/*for ( int ii = 1; ii < 5; ii += 1 )
		{
			if (( position.x == ii )||( position.y == ii )||
				( position.x == -ii )||( position.y == -ii ))
			{
				pBoob->current_resolution = (char)pow( 2, (double)ii );
				if ( pBoob->current_resolution > 4 )
				{
					pBoob->current_resolution = 4;
				}
			}
		}
		pBoob->current_resolution = 1;*/
		// END LoD SYS CHECK
		/*GenerateTerrain( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
		GenerateTerrain( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
		GenerateTerrain( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
		GenerateTerrain( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
		GenerateTerrain( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
		GenerateTerrain( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );*/

		ftype val;
		/*for ( unsigned int i = 0; i < 32768; i += 1 )
		{
			val = noise.Get3D(
				position.x + ( i%32 )/32.0f,
				position.y + ( (i/32)%32 )/32.0f,
				position.z + ( ((i/32)/32)%32 )/32.0f
				);
			if ( val > ( ((i/32)/32)%32 )/32.0f-1 )
				pBoob->data[i] = 1;
			else
				pBoob->data[i] = 0;
		}*/
		for ( char i = 0; i < 8; i += 1 )
		{
			for ( char j = 0; j < 8; j += 1 )
			{
				for ( int k = 0; k < 512; k += 1 )
				{
					val = noise.Get3D(
						position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f,
						position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f,
						position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f
						);
					//if ( val > ( ((i/32)/32)%32 )/32.0f-1 )
					//if ( val > 0.0f )
					//if ( val > (position.z + ((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f-1 )
					if ( val > (position.z*32 + ((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f-1 )
						pBoob->data[i].data[j].data[k] = 1;
					else
						pBoob->data[i].data[j].data[k] = 0;
					//pBoob->data[i].data[j].data[k] = 0;
				}
			}
		}
		//pBoob->data[1].data[1].data[100] = 0;
		//pBoob->data[1].data[1].data[100-64] = 1;
	}
}

void CVoxelTerrain::GenerateCube ( void )
{
	Vector3d vertexData[8];
	vertexData[0].x = 0;
	vertexData[0].y = 0;
	vertexData[0].z = 0;

	vertexData[1].x = 2;
	vertexData[1].y = 0;
	vertexData[1].z = 0;

	vertexData[2].x = 2;
	vertexData[2].y = 2;
	vertexData[2].z = 0;

	vertexData[3].x = 0;
	vertexData[3].y = 2;
	vertexData[3].z = 0;

	vertexData[4].x = 0;
	vertexData[4].y = 0;
	vertexData[4].z = 2;

	vertexData[5].x = 2;
	vertexData[5].y = 0;
	vertexData[5].z = 2;

	vertexData[6].x = 2;
	vertexData[6].y = 2;
	vertexData[6].z = 2;

	vertexData[7].x = 0;
	vertexData[7].y = 2;
	vertexData[7].z = 2;

	glNewList( iCubeList, GL_COMPILE );
	glBegin( GL_QUADS );
		// Bottom
		glColor3f(1.0f,0.0f,0.0f);
		glNormal3f( 0,0,-1 );
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
		// Top
		glColor3f(0.0f,1.0f,0.0f);//
		glNormal3f( 0,0,1 );
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
		// Front
		glColor3f(0.0f,0.0f,1.0f);
		glNormal3f( 1,0,0 );
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
		// Back
		glColor3f(1.0f,1.0f,0.0f);
		glNormal3f( -1,0,0 );
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
		// Left
		glColor3f(1.0f,0.0f,1.0f);//
		glNormal3f( 0,1,0 );
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
		// Right
		glColor3f(0.0f,1.0f,1.0f);
		glNormal3f( 0,-1,0 );
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+BOTTOM-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Bottom 0
		glColor3f(1.0f,0.0f,0.0f);
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+TOP-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Top 1 
		glColor3f(0.0f,1.0f,0.0f);//
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+FRONT-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Front 2
		glColor3f(0.0f,0.0f,1.0f);
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+BACK-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Back 3 
		glColor3f(1.0f,1.0f,0.0f);
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+LEFT-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Left 4
		glColor3f(1.0f,0.0f,1.0f);//
		glVertex3f( vertexData[3].x,vertexData[3].y,vertexData[3].z );
		glVertex3f( vertexData[0].x,vertexData[0].y,vertexData[0].z );
		glVertex3f( vertexData[4].x,vertexData[4].y,vertexData[4].z );
		glVertex3f( vertexData[7].x,vertexData[7].y,vertexData[7].z );
	glEnd();
	glEndList();

	glNewList( iFaceList+RIGHT-1, GL_COMPILE );
	glBegin( GL_QUADS );
		// Right 5
		glColor3f(0.0f,1.0f,1.0f);
		glVertex3f( vertexData[6].x,vertexData[6].y,vertexData[6].z );
		glVertex3f( vertexData[5].x,vertexData[5].y,vertexData[5].z );
		glVertex3f( vertexData[1].x,vertexData[1].y,vertexData[1].z );
		glVertex3f( vertexData[2].x,vertexData[2].y,vertexData[2].z );
	glEnd();
	glEndList();
}



// Rendering
bool CVoxelTerrain::Render ( void )
{
	//glEnable(GL_CULL_FACE);
	//RenderBoob( root, root_position );
	//RenderTree32( root, root_position );


	//---------------
	glLoadIdentity();
	// Render the terrain

	// bind VBOs for vertex array and index array
	glBindBufferARB(GL_ARRAY_BUFFER_ARB, iVBOverts);         // for vertex coordinates
	glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces); // for face vertex indexes

	// Create the terrain vertex data
	//if ( needUpdateOnVBO||stepNum ==  )
	if ( stepNum == 0 )
		GenerateVBO();
	stepNum = 3;
	needUpdateOnVBO = false;

	// do same as vertex array except pointer
	glEnableClientState(GL_VERTEX_ARRAY);             // activate vertex coords array
	glEnableClientState(GL_NORMAL_ARRAY);
    //glEnableClientState(GL_COLOR_ARRAY);

	// Tell where the vertex coordinates are in the array
	glVertexPointer( 3, GL_FLOAT, sizeof(CTerrainVertex), 0 ); 
	//glNormalPointer( GL_FLOAT, sizeof(CTerrainVertex), (char*)0 + (sizeof(float)*6) );
	glNormalPointer( GL_FLOAT, sizeof(CTerrainVertex), ((char*)0) + (sizeof(float)*6) );
	//glColorPointer( 4, GL_FLOAT, sizeof(CTerrainVertex), (char*)0 + (sizeof(float)*12) );

	// Draw the sutff
	glDrawElements( GL_QUADS, faceCount*4, GL_UNSIGNED_INT, 0 );

	glDisableClientState(GL_VERTEX_ARRAY);            // deactivate vertex array
	glDisableClientState(GL_NORMAL_ARRAY);
    //glDisableClientState(GL_COLOR_ARRAY);

	// bind with 0, so, switch back to normal pointer operation
	glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
	glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);

	return true;
}

void CVoxelTerrain::RenderTree32 ( CBoob * pBoob, LongIntPosition const& position )
{
	if ( pBoob != NULL )
	{
		if ( pBoob->bitinfo[1] == false )
		{
			// Set drawn flag
			pBoob->bitinfo[1] = true;

			// If visible...
			if ( pBoob->bitinfo[0] == true )
			{
				// Draw current boob
				for ( char i = 0; i < 8; i += 1 )
				{
					if ( pBoob->visible[i] )
					{
						RenderTree16( pBoob, &(pBoob->data[i]), i, position );
					}
				}
			}

			// Draw other boobs
			RenderTree32( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
			RenderTree32( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
			RenderTree32( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
			RenderTree32( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
			RenderTree32( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
			RenderTree32( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		}
	}
}
void CVoxelTerrain::RenderTree16 ( CBoob * pBoob, subblock16 * block, char const& index, LongIntPosition const& position )
{
	// Draw current block
	for ( char i = 0; i < 8; i += 1 )
	{
		if ( block->visible[i] )
		{
			RenderTree8( pBoob, &(block->data[i]), index, i, position );
		}
	}
}
void CVoxelTerrain::RenderTree8 ( CBoob * pBoob, subblock8 * block, char const& index, char const& subindex, LongIntPosition const& position )
{
	// Draw current block
	Vector3d baseOffset = Vector3d(
		position.x*32.0f+((index%2)*16)+((subindex%2)*8),
		position.y*32.0f+(((index/2)%2)*16)+(((subindex/2)%2)*8),
		position.z*32.0f+((index/4)*16)+((subindex/4)*8) );

	Vector3d pos;

	// Draw current block
	char res = pBoob->current_resolution;
	char i, j, k;
	for ( k = 0; k < 8; k += res )
	{
		for ( j = 0; j < 8; j += res )
		{
			for ( i = 0; i < 8; i += res )
			{
				if ( block->data[i+j*8+k*64] > 0 )
				{
					if ( BlockVisibleEx( (char*)(block->data), i+j*8+k*64, 8 ) )
					{
						pos.x = baseOffset.x + i;
						pos.y = baseOffset.y + j;
						pos.z = baseOffset.z + k;
						RenderBlock( pos*2.0f, res );
					}
				}
			}
		}
	}
}

void CVoxelTerrain::GenerateVBO ( void )
{
	//GL_STREAM_DRAW_ARB
	// TODO
	// bind VBO in order to use
	/*glBindBufferARB( GL_ARRAY_BUFFER_ARB, iVBOverts );
	glBufferDataARB( GL_ARRAY_BUFFER_ARB, 0, NULL, GL_STREAM_DRAW_ARB );
	CTerrainVertex* vertices = (CTerrainVertex*)glMapBufferARB( GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB );

	glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces );
	glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0, NULL, GL_STREAM_DRAW_ARB );
	CModelQuad* quads = (CModelQuad*)glMapBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB );

	vertexCount = 0;
	faceCount = 0;

	GenerateTree32( root, root_position );

	glUnmapBufferARB( GL_ARRAY_BUFFER_ARB );
	glUnmapBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB );*/

	/*for ( unsigned int i = 0; i < vertexCount; i += 1 )
	{
		vertices[i].r = 1.0f;
		vertices[i].g = 1.0f;
		vertices[i].b = 1.0f;
		vertices[i].a = 1.0f;
	}

	vertexCount = 0;
	faceCount = 0;
	
	GenerateTree32( root, root_position );

	glBindBufferARB( GL_ARRAY_BUFFER_ARB, iVBOverts );
	glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces );
	glBufferDataARB( GL_ARRAY_BUFFER_ARB, vertexCount*sizeof(CTerrainVertex), vertices, GL_STREAM_DRAW_ARB );
	glBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, faceCount*sizeof(CModelQuad), quads, GL_STREAM_DRAW_ARB );*/

	/*for ( unsigned int i = 0; i < vertexCount; i += 1 )
	{
		vertices[i].r = 1.0f;
		vertices[i].g = 1.0f;
		vertices[i].b = 1.0f;
		vertices[i].a = 1.0f;
	}*/
	vertexCount = 0;
	faceCount = 0;
	GenerateTree32( root, root_position ); //massive slowdown
	/*for ( unsigned int i = 0; i < vertexCount; i += 1 )
	{
		vertices[i].r = 1.0f;
		vertices[i].g = 1.0f;
		vertices[i].b = 1.0f;
		vertices[i].a = 1.0f;
	}*/

	/*glBindBufferARB( GL_ARRAY_BUFFER_ARB, iVBOverts );
	glBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, iVBOfaces );*/
	glBufferSubDataARB( GL_ARRAY_BUFFER_ARB, 0, vertexCount*sizeof(CTerrainVertex), vertices );
	glBufferSubDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0, faceCount*sizeof(CModelQuad), quads );


}
void CVoxelTerrain::GenerateTree32 ( CBoob * pBoob, LongIntPosition const& position )
{
	if ( pBoob != NULL )
	{
		if ( pBoob->bitinfo[1] == false )
		{
			// Set drawn flag
			pBoob->bitinfo[1] = true;

			// If visible...
			if ( pBoob->bitinfo[0] == true )
			{
				// Draw current boob
				for ( char i = 0; i < 8; i += 1 )
				{
					if ( pBoob->visible[i] )
					{
						GenerateTree16( pBoob, &(pBoob->data[i]), i, position );
					}
				}
			}

			// Draw other boobs
			GenerateTree32( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
			GenerateTree32( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
			GenerateTree32( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
			GenerateTree32( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
			GenerateTree32( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
			GenerateTree32( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		}
	}
}
void CVoxelTerrain::GenerateTree16 ( CBoob * pBoob, subblock16 * block, char const index, LongIntPosition const& position )
{
	// Draw current block
	for ( char i = 0; i < 8; i += 1 )
	{
		if ( block->visible[i] )
		{
			GenerateTree8( pBoob, &(block->data[i]), index, i, position );
		}
	}
}
void CVoxelTerrain::GenerateTree8 ( CBoob * pBoob, subblock8 * block, char const index, char const subindex, LongIntPosition const& position )
{
	// Draw current block
	Vector3d baseOffset = Vector3d(
		position.x*32.0f+((index%2)*16)+((subindex%2)*8),
		position.y*32.0f+(((index/2)%2)*16)+(((subindex/2)%2)*8),
		position.z*32.0f+((index/4)*16)+((subindex/4)*8) );

	Vector3d pos;

	//const int bsize = 2;

	// Draw current block
	char res = pBoob->current_resolution;
	char i, j, k;
	for ( k = 0; k < 8; k += res )
	{
		for ( j = 0; j < 8; j += res )
		{
			for ( i = 0; i < 8; i += res )
			{
				if ( block->data[i+j*8+k*64] > 0 )
				{
					if ( BlockVisibleEx( (char*)(block->data), i+j*8+k*64, 8 ) )
					{
						pos.x = (baseOffset.x + (ftype)i)*2.0f;
						pos.y = (baseOffset.y + (ftype)j)*2.0f;
						pos.z = (baseOffset.z + (ftype)k)*2.0f;

						GenerateCube( pBoob, index,subindex,i+j*8+k*64, pos, res );
					}
					/*if ( BlockVisibleEx( (char*)(block->data), i+j*8+k*64, 8 ) )
					{
						pos.x = (baseOffset.x + (ftype)i)*2.0f;
						pos.y = (baseOffset.y + (ftype)j)*2.0f;
						pos.z = (baseOffset.z + (ftype)k)*2.0f;
						
						vertices[vertexCount].x = pos.x;
						vertices[vertexCount].y = pos.y;
						vertices[vertexCount].z = pos.z;
						vertices[vertexCount].r = 0;

						vertices[vertexCount+1].x = pos.x+bsize*res;
						vertices[vertexCount+1].y = pos.y;
						vertices[vertexCount+1].z = pos.z;
						vertices[vertexCount+1].g = 0;

						vertices[vertexCount+2].x = pos.x+bsize*res;
						vertices[vertexCount+2].y = pos.y+bsize*res;
						vertices[vertexCount+2].z = pos.z;
						vertices[vertexCount+2].b = 0;

						vertices[vertexCount+3].x = pos.x;
						vertices[vertexCount+3].y = pos.y+bsize*res;
						vertices[vertexCount+3].z = pos.z;
						vertices[vertexCount+3].r = 0;
						vertices[vertexCount+3].g = 0;

						vertices[vertexCount+4].x = pos.x;
						vertices[vertexCount+4].y = pos.y;
						vertices[vertexCount+4].z = pos.z+bsize*res;
						vertices[vertexCount+4].g = 0;
						vertices[vertexCount+4].b = 0;

						vertices[vertexCount+5].x = pos.x+bsize*res;
						vertices[vertexCount+5].y = pos.y;
						vertices[vertexCount+5].z = pos.z+bsize*res;
						vertices[vertexCount+5].r = 0;
						vertices[vertexCount+5].b = 0;

						vertices[vertexCount+6].x = pos.x+bsize*res;
						vertices[vertexCount+6].y = pos.y+bsize*res;
						vertices[vertexCount+6].z = pos.z+bsize*res;
						vertices[vertexCount+6].r = 0.5f;
						vertices[vertexCount+6].g = 0.5f;

						vertices[vertexCount+7].x = pos.x;
						vertices[vertexCount+7].y = pos.y+bsize*res;
						vertices[vertexCount+7].z = pos.z+bsize*res;
						// BOTTOM
						quads[faceCount].vert[0] = vertexCount+3;
						quads[faceCount].vert[1] = vertexCount+2;
						quads[faceCount].vert[2] = vertexCount+1;
						quads[faceCount].vert[3] = vertexCount+0;
						// TOP
						quads[faceCount+1].vert[0] = vertexCount+4;
						quads[faceCount+1].vert[1] = vertexCount+5;
						quads[faceCount+1].vert[2] = vertexCount+6;
						quads[faceCount+1].vert[3] = vertexCount+7;
						// FRONT
						quads[faceCount+2].vert[0] = vertexCount+5;
						quads[faceCount+2].vert[1] = vertexCount+4;
						quads[faceCount+2].vert[2] = vertexCount+0;
						quads[faceCount+2].vert[3] = vertexCount+1;
						// BACK
						quads[faceCount+3].vert[0] = vertexCount+7;
						quads[faceCount+3].vert[1] = vertexCount+6;
						quads[faceCount+3].vert[2] = vertexCount+2;
						quads[faceCount+3].vert[3] = vertexCount+3;
						// LEFT
						quads[faceCount+4].vert[0] = vertexCount+3;
						quads[faceCount+4].vert[1] = vertexCount+0;
						quads[faceCount+4].vert[2] = vertexCount+4;
						quads[faceCount+4].vert[3] = vertexCount+7;
						// RIGHT
						quads[faceCount+5].vert[0] = vertexCount+6;
						quads[faceCount+5].vert[1] = vertexCount+5;
						quads[faceCount+5].vert[2] = vertexCount+1;
						quads[faceCount+5].vert[3] = vertexCount+2;

						faceCount += 6;
						vertexCount += 8;

					}*/
				}
			}
		}
	}
}

void CVoxelTerrain::GenerateCube( CBoob * pBoob, char const index16, char const index8, int const indexd, Vector3d const& pos, char const res )
{
	static const int bsize = 2;
	unsigned int i = 0;
	//static Vector3d cpos;
	//cpos = pos + Vector3d( bsize*res*0.5,bsize*res*0.5,bsize*res*0.5 );
	static Vector3d dot;
	dot = pos - vCameraPos;

	// Generate FRONT
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, FRONT, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x+bsize*res;
		vertices[vertexCount+0].y = pos.y+bsize*res;
		vertices[vertexCount+0].z = pos.z+bsize*res;

		vertices[vertexCount+1].x = pos.x+bsize*res;
		vertices[vertexCount+1].y = pos.y;
		vertices[vertexCount+1].z = pos.z+bsize*res;

		vertices[vertexCount+2].x = pos.x+bsize*res;
		vertices[vertexCount+2].y = pos.y;
		vertices[vertexCount+2].z = pos.z;

		vertices[vertexCount+3].x = pos.x+bsize*res;
		vertices[vertexCount+3].y = pos.y+bsize*res;
		vertices[vertexCount+3].z = pos.z;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = 1;
			vertices[vertexCount+i].ny = 0;
			vertices[vertexCount+i].nz = 0;
		}

		vertexCount += 4;
		faceCount += 1;
	}
	// Generate BACK
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, BACK, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x;
		vertices[vertexCount+0].y = pos.y+bsize*res;
		vertices[vertexCount+0].z = pos.z;

		vertices[vertexCount+1].x = pos.x;
		vertices[vertexCount+1].y = pos.y;
		vertices[vertexCount+1].z = pos.z;

		vertices[vertexCount+2].x = pos.x;
		vertices[vertexCount+2].y = pos.y;
		vertices[vertexCount+2].z = pos.z+bsize*res;

		vertices[vertexCount+3].x = pos.x;
		vertices[vertexCount+3].y = pos.y+bsize*res;
		vertices[vertexCount+3].z = pos.z+bsize*res;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = -1;
			vertices[vertexCount+i].ny = 0;
			vertices[vertexCount+i].nz = 0;
		}

		vertexCount += 4;
		faceCount += 1;
	}
	// Generate RIGHT
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, RIGHT, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x+bsize*res;
		vertices[vertexCount+0].y = pos.y;
		vertices[vertexCount+0].z = pos.z+bsize*res;

		vertices[vertexCount+1].x = pos.x;
		vertices[vertexCount+1].y = pos.y;
		vertices[vertexCount+1].z = pos.z+bsize*res;

		vertices[vertexCount+2].x = pos.x;
		vertices[vertexCount+2].y = pos.y;
		vertices[vertexCount+2].z = pos.z;

		vertices[vertexCount+3].x = pos.x+bsize*res;
		vertices[vertexCount+3].y = pos.y;
		vertices[vertexCount+3].z = pos.z;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = 0;
			vertices[vertexCount+i].ny = -1;
			vertices[vertexCount+i].nz = 0;
		}

		vertexCount += 4;
		faceCount += 1;
	}
	// Generate LEFT
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, LEFT, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x+bsize*res;
		vertices[vertexCount+0].y = pos.y+bsize*res;
		vertices[vertexCount+0].z = pos.z;

		vertices[vertexCount+1].x = pos.x;
		vertices[vertexCount+1].y = pos.y+bsize*res;
		vertices[vertexCount+1].z = pos.z;

		vertices[vertexCount+2].x = pos.x;
		vertices[vertexCount+2].y = pos.y+bsize*res;
		vertices[vertexCount+2].z = pos.z+bsize*res;

		vertices[vertexCount+3].x = pos.x+bsize*res;
		vertices[vertexCount+3].y = pos.y+bsize*res;
		vertices[vertexCount+3].z = pos.z+bsize*res;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = 0;
			vertices[vertexCount+i].ny = 1;
			vertices[vertexCount+i].nz = 0;
		}

		vertexCount += 4;
		faceCount += 1;
	}
	// Generate TOP
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, TOP, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x;
		vertices[vertexCount+0].y = pos.y;
		vertices[vertexCount+0].z = pos.z+bsize*res;

		vertices[vertexCount+1].x = pos.x+bsize*res;
		vertices[vertexCount+1].y = pos.y;
		vertices[vertexCount+1].z = pos.z+bsize*res;

		vertices[vertexCount+2].x = pos.x+bsize*res;
		vertices[vertexCount+2].y = pos.y+bsize*res;
		vertices[vertexCount+2].z = pos.z+bsize*res;

		vertices[vertexCount+3].x = pos.x;
		vertices[vertexCount+3].y = pos.y+bsize*res;
		vertices[vertexCount+3].z = pos.z+bsize*res;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = 0;
			vertices[vertexCount+i].ny = 0;
			vertices[vertexCount+i].nz = 1;
		}

		vertexCount += 4;
		faceCount += 1;
	}
	// Generate BOTTOM
	if ( SideVisible( pBoob, index16, index8, (char*)pBoob->data[index16].data[index8].data,indexd,8, BOTTOM, res, dot ) )
	{
		vertices[vertexCount+0].x = pos.x;
		vertices[vertexCount+0].y = pos.y+bsize*res;
		vertices[vertexCount+0].z = pos.z;

		vertices[vertexCount+1].x = pos.x+bsize*res;
		vertices[vertexCount+1].y = pos.y+bsize*res;
		vertices[vertexCount+1].z = pos.z;

		vertices[vertexCount+2].x = pos.x+bsize*res;
		vertices[vertexCount+2].y = pos.y;
		vertices[vertexCount+2].z = pos.z;

		vertices[vertexCount+3].x = pos.x;
		vertices[vertexCount+3].y = pos.y;
		vertices[vertexCount+3].z = pos.z;

		quads[faceCount].vert[0] = vertexCount+0;
		quads[faceCount].vert[1] = vertexCount+1;
		quads[faceCount].vert[2] = vertexCount+2;
		quads[faceCount].vert[3] = vertexCount+3;

		for ( i = 0; i < 4; i += 1 )
		{
			vertices[vertexCount+i].nx = 0;
			vertices[vertexCount+i].ny = 0;
			vertices[vertexCount+i].nz = -1;
		}

		vertexCount += 4;
		faceCount += 1;
	}
}

bool CVoxelTerrain::SideVisible ( CBoob * pBoob, char const index16, char const index8, char * data, unsigned int const i, int const width, EFaceDir const dir )
{
	// TODO (not done but will work 4 now)
	/*
	if (( data[i+1024] == 0 ))
		glCallList( iFaceList+TOP-1 );
	if (( data[i-1024] == 0 ))
		glCallList( iFaceList+BOTTOM-1 );
	if (( data[i+32] == 0 ))
		glCallList( iFaceList+BACK-1 );
	if (( data[i-32] == 0 ))
		glCallList( iFaceList+FRONT-1 );
	if (( data[i+1] == 0 ))
		glCallList( iFaceList+RIGHT-1 );
	if (( data[i-1] == 0 ))
		glCallList( iFaceList+LEFT-1 );
		*/
	static unsigned char checkdata = 0;
	switch ( dir )
	{
	case FRONT:
		if ( i%width != width-1 )
		{
			checkdata = data[i+1];
		}
		else
		{
			if ( index8%2 != 1 )
			{
				checkdata = pBoob->data[index16].data[index8+1].data[i-(width-1)];
			}
			else if ( index16%2 != 1 )
			{
				checkdata = pBoob->data[index16+1].data[index8-1].data[i-(width-1)];
			}
			else if ( pBoob->front != NULL )
			{
				checkdata = pBoob->front->data[index16-1].data[index8-1].data[i-(width-1)];
			}
		}
		break;
	case BACK:
		if ( i%width != 0 )
		{
			checkdata = data[i-1];
		}
		else
		{
			if ( index8%2 != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-1].data[i+(width-1)];
			}
			else if ( index16%2 != 0 )
			{
				checkdata = pBoob->data[index16-1].data[index8+1].data[i+(width-1)];
			}
			else if ( pBoob->back != NULL )
			{
				checkdata = pBoob->back->data[index16+1].data[index8+1].data[i+(width-1)];
			}
		}
		break;
	case LEFT:
		if ( ((i/width)%width) != width-1 )
		{
			checkdata = data[i+width];
		}
		else
		{
			if ( ((index8/2)%2) != 1 )
			{
				checkdata = pBoob->data[index16].data[index8+2].data[i-(width*(width-1))];
			}
			else if ( ((index16/2)%2) != 1 )
			{
				checkdata = pBoob->data[index16+2].data[index8-2].data[i-(width*(width-1))];
			}
			else if ( pBoob->left != NULL )
			{
				checkdata = pBoob->left->data[index16-2].data[index8-2].data[i-(width*(width-1))];
			}
		}
		break;
	case RIGHT:
		if ( ((i/width)%width) != 0 )
		{
			checkdata = data[i-width];
		}
		else
		{
			if ( ((index8/2)%2) != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-2].data[i+(width*(width-1))];
			}
			else if ( ((index16/2)%2) != 0 )
			{
				checkdata = pBoob->data[index16-2].data[index8+2].data[i+(width*(width-1))];
			}
			else if ( pBoob->right != NULL )
			{
				checkdata = pBoob->right->data[index16+2].data[index8+2].data[i+(width*(width-1))];
			}
		}
		break;
	case TOP:
		if ( ((i/width/width)%width) != width-1 )
		{
			checkdata = data[i+(width*width)];
		}
		else
		{
			if ( ((index8/4)%2) != 1 )
			{
				checkdata = pBoob->data[index16].data[index8+4].data[i-(width*width*(width-1))];
			}
			else if ( ((index16/4)%2) != 1 )
			{
				checkdata = pBoob->data[index16+4].data[index8-4].data[i-(width*width*(width-1))];
			}
			else if ( pBoob->top != NULL )
			{
				checkdata = pBoob->top->data[index16-4].data[index8-4].data[i-(width*width*(width-1))];
			}
		}
		break;
	case BOTTOM:
		if ( ((i/width/width)%width) != 0 )
		{
			checkdata = data[i-(width*width)];
		}
		else
		{
			if ( ((index8/4)%2) != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-4].data[i+(width*width*(width-1))];
			}
			else if ( ((index16/4)%2) != 0 )
			{
				checkdata = pBoob->data[index16-4].data[index8+4].data[i+(width*width*(width-1))];
			}
			else if ( pBoob->bottom != NULL )
			{
				checkdata = pBoob->bottom->data[index16+4].data[index8+4].data[i+(width*width*(width-1))];
			}
		}
		break;
	/*case LEFT:
		if ( ((i/width)%width) != 0 )
		{
			checkdata = data[i-width];
		}
		else
		{
			if ( ((index8/2)%2) != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-2].data[i+(width*(width-1))];
			}
		}
		break;
	case RIGHT:
		if ( ((i/width)%width) != width-1 )
		{
			checkdata = data[i+width];
		}
		else
		{
			if ( ((index8/2)%2) != 1 )
			{
				checkdata = pBoob->data[index16].data[index8+2].data[i-(width*(width-1))];
			}
		}
		break;*/
	/*case FRONT:
		if ( ((i/width)%width) != 0 )
		{
			checkdata = data[i-width];
		}
		else
		{
			if ( ((index8/2)%2) != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-2].data[i+(width*(width-1))];
			}
		}
		break;
	case LEFT:
		if ( i%width != 0 )
		{
			checkdata = data[i-1];
		}
		else
		{
			if ( index8%2 != 0 )
			{
				checkdata = pBoob->data[index16].data[index8-1].data[i+(width-1)];
			}
		}
		break;
	case RIGHT:
		if ( i%width != width-1 )
		{
			checkdata = data[i+1];
		}
		else
		{
			if ( index8%2 != 1 )
			{
				checkdata = pBoob->data[index16].data[index8+1].data[i-(width-1)];
			}
		}
		break;*/
	}
	return (checkdata==0);
}

bool CVoxelTerrain::SideVisible ( CBoob * pBoob, char const index16, char const index8, char * data, int const i, int const width, EFaceDir const dir, unsigned char ofs, Vector3d const& dot )
{
	static unsigned char checkdata = 1;
	//static Vector3d vDir;
	//vDir = pos - vCameraPos;

	switch ( dir )
	{
	case FRONT:
		if ( dot.x < 0.0f )
		{
			if ( i%width < width-ofs )
			{
				checkdata = data[i+ofs];
			}
			else
			{
				if ( index8%2 != 1 )
				{
					checkdata = pBoob->data[index16].data[index8+1].data[i-(width-ofs)];
				}
				else if ( index16%2 != 1 )
				{
					checkdata = pBoob->data[index16+1].data[index8-1].data[i-(width-ofs)];
				}
				else if ( pBoob->front != NULL )
				{
					checkdata = pBoob->front->data[index16-1].data[index8-1].data[i-(width-ofs)];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	case BACK:
		if ( dot.x > 0 )
		{
			if ( i%width >= ofs )
			{
				checkdata = data[i-ofs];
			}
			else
			{
				if ( index8%2 != 0 )
				{
					checkdata = pBoob->data[index16].data[index8-1].data[i+(width-ofs)];
				}
				else if ( index16%2 != 0 )
				{
					checkdata = pBoob->data[index16-1].data[index8+1].data[i+(width-ofs)];
				}
				else if ( pBoob->back != NULL )
				{
					checkdata = pBoob->back->data[index16+1].data[index8+1].data[i+(width-ofs)];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	case LEFT:
		if ( dot.y < 0 )
		{
			if ( ((i/width)%width) < width-ofs )
			{
				checkdata = data[i+(width*ofs)];
			}
			else
			{
				if ( ((index8/2)%2) != 1 )
				{
					checkdata = pBoob->data[index16].data[index8+2].data[i-(width*(width-ofs))];
				}
				else if ( ((index16/2)%2) != 1 )
				{
					checkdata = pBoob->data[index16+2].data[index8-2].data[i-(width*(width-ofs))];
				}
				else if ( pBoob->left != NULL )
				{
					checkdata = pBoob->left->data[index16-2].data[index8-2].data[i-(width*(width-ofs))];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	case RIGHT:
		if ( dot.y > 0 )
		{
			if ( ((i/width)%width) >= ofs )
			{
				checkdata = data[i-(width*ofs)];
			}
			else
			{
				if ( ((index8/2)%2) != 0 )
				{
					checkdata = pBoob->data[index16].data[index8-2].data[i+(width*(width-ofs))];
				}
				else if ( ((index16/2)%2) != 0 )
				{
					checkdata = pBoob->data[index16-2].data[index8+2].data[i+(width*(width-ofs))];
				}
				else if ( pBoob->right != NULL )
				{
					checkdata = pBoob->right->data[index16+2].data[index8+2].data[i+(width*(width-ofs))];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	case TOP:
		if ( dot.z < 0 )
		{
			if ( ((i/width/width)%width) != width-ofs )
			{
				checkdata = data[i+(width*width*ofs)];
			}
			else
			{
				if ( ((index8/4)%2) != 1 )
				{
					checkdata = pBoob->data[index16].data[index8+4].data[i-(width*width*(width-ofs))];
				}
				else if ( ((index16/4)%2) != 1 )
				{
					checkdata = pBoob->data[index16+4].data[index8-4].data[i-(width*width*(width-ofs))];
				}
				else if ( pBoob->top != NULL )
				{
					checkdata = pBoob->top->data[index16-4].data[index8-4].data[i-(width*width*(width-ofs))];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	case BOTTOM:
		if ( dot.z > 0 )
		{
			if ( ((i/width/width)%width) >= ofs )
			{
				checkdata = data[i-(width*width*ofs)];
			}
			else
			{
				if ( ((index8/4)%2) != 0 )
				{
					checkdata = pBoob->data[index16].data[index8-4].data[i+(width*width*(width-ofs))];
				}
				else if ( ((index16/4)%2) != 0 )
				{
					checkdata = pBoob->data[index16-4].data[index8+4].data[i+(width*width*(width-ofs))];
				}
				else if ( pBoob->bottom != NULL )
				{
					checkdata = pBoob->bottom->data[index16+4].data[index8+4].data[i+(width*width*(width-ofs))];
				}
				else
					return false;
			}
		}
		else
			return false;
		break;
	}
	return (checkdata==0);
}

void CVoxelTerrain::RenderBoob ( CBoob * pBoob, LongIntPosition const& position  )
{
	if ( pBoob != NULL )
	{
		/*RenderBoob( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
		RenderBoob( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
		RenderBoob( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
		RenderBoob( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
		RenderBoob( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
		RenderBoob( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );*/
		// FIX THIS
		if ( position.z >= 0 )
			RenderBoob( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
		if ( position.x >= 0 )
			RenderBoob( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
		if ( position.y >= 0 )
			RenderBoob( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
		if ( position.z <= 0 )
			RenderBoob( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
		if ( position.x <= 0 )
			RenderBoob( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
		if ( position.y <= 0 )
			RenderBoob( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );

		if ( renderMethod == 0 )
		{
			for ( unsigned int i = 0; i < 32768; i += 1 )
			{
				/*if ( pBoob->data[i] )
				{
					RenderBlockExp( Vector3d(
						(ftype)(( position.x*boobSize.x + (int)(i%32) )*2),
						(ftype)(( position.y*boobSize.y + (int)((i/32)%32) )*2),
						(ftype)(( position.z*boobSize.z + (int)(((i/32)/32)%32) ))*2),
						pBoob, i
						);
				}*/
			}
		}
		else
		{
			for ( unsigned int i = 0; i < 32768; i += 1 )
			{
				/*if (( pBoob->data[i] > 0 )&&( BlockVisible( (char*)pBoob->data, i ) ))
				{
					RenderBlock( Vector3d(
						(ftype)(( position.x*boobSize.x + (int)(i%32) )*2),
						(ftype)(( position.y*boobSize.y + (int)((i/32)%32) )*2),
						(ftype)(( position.z*boobSize.z + (int)(((i/32)/32)%32) ))*2)
						);
				}*/
			}
		}
	}
}

bool CVoxelTerrain::BlockVisible ( char * data, unsigned int const& i )
{
	if (( i%32 == 0 )||( i%32 == 31 ))
		return true;
	if (( (i/32)%32 == 0 )||( (i/32)%32 == 31 ))
		return true;
	if (( (i/32/32)%32 == 0 )||( (i/32/32)%32 == 31 ))
		return true;
	if (( data[i-1] == 0 )||( data[i+1] == 0 ))
		return true;
	if (( data[i+32] == 0 )||( data[i-32] == 0 ))
		return true;
	if (( data[i+1024] == 0 )||( data[i-1024] == 0 ))
		return true;
	return false;
}
bool CVoxelTerrain::BlockVisibleEx ( char * data, unsigned int const& i, int const& width )
{
	if (( i%width == 0 )||( i%width == width-1 ))
		return true;
	if (( (i/width)%width == 0 )||( (i/width)%width == width-1 ))
		return true;
	if (( (i/width/width)%width == 0 )||( (i/width/width)%width == width-1 ))
		return true;
	if (( data[i-1] == 0 )||( data[i+1] == 0 ))
		return true;
	if (( data[i+width] == 0 )||( data[i-width] == 0 ))
		return true;
	if (( data[i+width*width] == 0 )||( data[i-width*width] == 0 ))
		return true;
	return false;
}
bool CVoxelTerrain::BlockVisibleEx ( CBoob * pBoob, subblock8 * block, char const& index, char const& subindex, char * data, unsigned int const& i, int const& width )
{
	static char check_data [6];
	if ((i%width != 0))
	{
		check_data[0] = data[i-1];
	}
	else
	{
		if ( pBoob->front )
		{

		}
		else
		{
			return false;
		}
	}
	/*if (( i%width == 0 )||( i%width == width-1 ))
		return true;
	if (( (i/width)%width == 0 )||( (i/width)%width == width-1 ))
		return true;
	if (( (i/width/width)%width == 0 )||( (i/width/width)%width == width-1 ))
		return true;
	if (( data[i-1] == 0 )||( data[i+1] == 0 ))
		return true;
	if (( data[i+width] == 0 )||( data[i-width] == 0 ))
		return true;
	if (( data[i+width*width] == 0 )||( data[i-width*width] == 0 ))*/
		return true;
	return false;
}

void CVoxelTerrain::RenderBlock ( Vector3d const& position )
{
	glLoadIdentity();	
	glTranslatef( position.x, position.y, position.z );
	glCallList( iCubeList );
	/*glCallList( iFaceList );
	glCallList( iFaceList+1 );
	glCallList( iFaceList+2 );
	glCallList( iFaceList+3 );
	glCallList( iFaceList+4 );
	glCallList( iFaceList+5 );*/
}
void CVoxelTerrain::RenderBlock ( Vector3d const& position, char const& scale )
{
	glLoadIdentity();
	glTranslatef( position.x, position.y, position.z );
	glScalef( scale,scale,scale );
	glCallList( iCubeList );
	/*glCallList( iFaceList );
	glCallList( iFaceList+1 );
	glCallList( iFaceList+2 );
	glCallList( iFaceList+3 );
	glCallList( iFaceList+4 );
	glCallList( iFaceList+5 );*/
}

/*void CVoxelTerrain::RenderBlockExp ( Vector3d const& position, CBoob * pBoob, unsigned int const& i )
{
	//if ( !CCamera::pActiveCamera->PointIsVisible( position ) )
	//	return;

	char * data = (char*)pBoob->data;

	if (( i%32 == 0 )||( i%32 == 31 ))
		return RenderBlock( position );
	if (( (i/32)%32 == 0 )||( (i/32)%32 == 31 ))
		return RenderBlock( position );
	if (( (i/32/32)%32 == 0 )||( (i/32/32)%32 == 31 ))
		return RenderBlock( position );
	if (( i%32 == 0 )||( i%32 == 31 ))
		return;
	if (( (i/32)%32 == 0 )||( (i/32)%32 == 31 ))
		return;
	if (( (i/32/32)%32 == 0 )||( (i/32/32)%32 == 31 ))
		return;
	glLoadIdentity();	
	glTranslatef( position.x, position.y, position.z );
	if (( data[i+1024] == 0 ))
		glCallList( iFaceList+1 );
	if (( data[i-1024] == 0 ))
		glCallList( iFaceList );
	if (( data[i+32] == 0 ))
		glCallList( iFaceList+3 );
	if (( data[i-32] == 0 ))
		glCallList( iFaceList+2 );
	if (( data[i+1] == 0 ))
		glCallList( iFaceList+5 );
	if (( data[i-1] == 0 ))
		glCallList( iFaceList+4 );
}*/

void CVoxelTerrain::RenderBlockExp ( Vector3d const& position, CBoob * pBoob, unsigned int const& i )
{
	//if ( !CCamera::pActiveCamera->PointIsVisible( position ) )
	//	return;

	char * data = (char*)pBoob->data;

	if (( i%32 == 0 )||( i%32 == 31 ))
		return RenderBlock( position );
	if (( (i/32)%32 == 0 )||( (i/32)%32 == 31 ))
		return RenderBlock( position );
	if (( (i/32/32)%32 == 0 )||( (i/32/32)%32 == 31 ))
		return RenderBlock( position );
	if (( i%32 == 0 )||( i%32 == 31 ))
		return;
	if (( (i/32)%32 == 0 )||( (i/32)%32 == 31 ))
		return;
	if (( (i/32/32)%32 == 0 )||( (i/32/32)%32 == 31 ))
		return;
	glLoadIdentity();	
	glTranslatef( position.x, position.y, position.z );
	/*if (( data[i-1024] != 0 )&&( vCameraDir.z < 0 ))
		glCallList( iFaceList+1 );
	if (( data[i+1024] != 0 )&&( vCameraDir.z > 0 ))
		glCallList( iFaceList );
	if (( data[i-32] != 0 )&&( vCameraDir.y < 0 ))
		glCallList( iFaceList+3 );
	if (( data[i+32] != 0 )&&( vCameraDir.y > 0 ))
		glCallList( iFaceList+2 );
	if (( data[i-1] != 0 )&&( vCameraDir.x < 0 ))
		glCallList( iFaceList+5 );
	if (( data[i+1] != 0 )&&( vCameraDir.x > 0 ))
		glCallList( iFaceList+4 );*/
	if (( data[i+1024] == 0 ))
		glCallList( iFaceList+TOP-1 );
	if (( data[i-1024] == 0 ))
		glCallList( iFaceList+BOTTOM-1 );
	if (( data[i+32] == 0 ))
		glCallList( iFaceList+BACK-1 );
	if (( data[i-32] == 0 ))
		glCallList( iFaceList+FRONT-1 );
	if (( data[i+1] == 0 ))
		glCallList( iFaceList+RIGHT-1 );
	if (( data[i-1] == 0 ))
		glCallList( iFaceList+LEFT-1 );
}

/** 1 top 2 bottom
// 3 front 4 back
// 5 left 6 right
**/
void CVoxelTerrain::LinkCube ( CBoob * pOld, CBoob * pNew, char const& c )
{
	switch ( c )
	{
	case 1: // new top link
		pOld->top = pNew;
		pNew->bottom = pOld;
		if ( pOld->left )
			if ( pOld->left->top )
			{
				pOld->left->top->right = pNew;
				pNew->left = pOld->left->top;
			}
		if ( pOld->right )
			if ( pOld->right->top )
			{
				pOld->right->top->left = pNew;
				pNew->right = pOld->right->top;
			}
		if ( pOld->front )
			if ( pOld->front->top )
			{
				pOld->front->top->back = pNew;
				pNew->front = pOld->front->top;
			}
		if ( pOld->back )
			if ( pOld->back->top )
			{
				pOld->back->top->front = pNew;
				pNew->back = pOld->back->top;
			}
		break;
	case 2: // new bottom link
		pOld->bottom = pNew;
		pNew->top = pOld;
		if ( pOld->left )
			if ( pOld->left->bottom )
			{
				pOld->left->bottom->right = pNew;
				pNew->left = pOld->left->bottom;
			}
		if ( pOld->right )
			if ( pOld->right->bottom )
			{
				pOld->right->bottom->left = pNew;
				pNew->right = pOld->right->bottom;
			}
		if ( pOld->front )
			if ( pOld->front->bottom )
			{
				pOld->front->bottom->back = pNew;
				pNew->front = pOld->front->bottom;
			}
		if ( pOld->back )
			if ( pOld->back->bottom )
			{
				pOld->back->bottom->front = pNew;
				pNew->back = pOld->back->bottom;
			}
		break;
	case 3: // new front link
		pOld->front = pNew;
		pNew->back = pOld;
		if ( pOld->left )
			if ( pOld->left->front )
			{
				pOld->left->front->right = pNew;
				pNew->left = pOld->left->front;
			}
		if ( pOld->right )
			if ( pOld->right->front )
			{
				pOld->right->front->left = pNew;
				pNew->right = pOld->right->front;
			}
		if ( pOld->top )
			if ( pOld->top->front )
			{
				pOld->top->front->bottom = pNew;
				pNew->top = pOld->top->front;
			}
		if ( pOld->bottom )
			if ( pOld->bottom->front )
			{
				pOld->bottom->front->top = pNew;
				pNew->bottom = pOld->bottom->front;
			}
		break;
	case 4: // new back link
		pOld->back = pNew;
		pNew->front = pOld;
		if ( pOld->left )
			if ( pOld->left->back )
			{
				pOld->left->back->right = pNew;
				pNew->left = pOld->left->back;
			}
		if ( pOld->right )
			if ( pOld->right->back )
			{
				pOld->right->back->left = pNew;
				pNew->right = pOld->right->back;
			}
		if ( pOld->top )
			if ( pOld->top->back )
			{
				pOld->top->back->bottom = pNew;
				pNew->top = pOld->top->back;
			}
		if ( pOld->bottom )
			if ( pOld->bottom->back )
			{
				pOld->bottom->back->top = pNew;
				pNew->bottom = pOld->bottom->back;
			}
		break;
	case 5: // new left link
		pOld->left = pNew;
		pNew->right = pOld;
		if ( pOld->top )
			if ( pOld->top->left )
			{
				pOld->top->left->bottom = pNew;
				pNew->top = pOld->top->left;
			}
		if ( pOld->bottom )
			if ( pOld->bottom->left )
			{
				pOld->bottom->left->top = pNew;
				pNew->bottom = pOld->bottom->left;
			}
		if ( pOld->front )
			if ( pOld->front->left )
			{
				pOld->front->left->back = pNew;
				pNew->front = pOld->front->left;
			}
		if ( pOld->back )
			if ( pOld->back->left )
			{
				pOld->back->left->front = pNew;
				pNew->back = pOld->back->left;
			}
		break;
	case 6: // new right link
		pOld->right = pNew;
		pNew->left = pOld;
		if ( pOld->top )
			if ( pOld->top->right )
			{
				pOld->top->right->bottom = pNew;
				pNew->top = pOld->top->right;
			}
		if ( pOld->bottom )
			if ( pOld->bottom->right )
			{
				pOld->bottom->right->top = pNew;
				pNew->bottom = pOld->bottom->right;
			}
		if ( pOld->front )
			if ( pOld->front->right )
			{
				pOld->front->right->back = pNew;
				pNew->front = pOld->front->right;
			}
		if ( pOld->back )
			if ( pOld->back->right )
			{
				pOld->back->right->front = pNew;
				pNew->back = pOld->back->right;
			}
		break;
	}
}