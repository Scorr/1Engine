// Includes
#include "CVoxelTerrain.h"
#include "CFoliageTree.h"
#include "CTreeBase.h"

//==Static variable declares==
/*
Perlin					CVoxelTerrain::noise		= Perlin( 4,4,1,0 );
*/

// Begin to generate the terrain
void CVoxelTerrain::GenerateTerrain ( CBoob * pBoob, LongIntPosition const& position )
{
	noise	= new Perlin( 1,2,1,iTerrainSeed );
	noise_hf= new Perlin( 1,5,1,iTerrainSeed );
	noise_hhf=new Perlin( 1,15,1,iTerrainSeed );
	noise_lf= new Perlin( 1,0.5f,1,iTerrainSeed );
	noise_biome= new Perlin( 1,0.2f,1,iTerrainSeed );

	// Primary main terrain pass
	DebugConsole::PrintMessage( "   Primary pass (terrain)...\n" );
	GenerateTerrainSector( pBoob, position );
	// Grass and various object generation pass
	DebugConsole::PrintMessage( "   Secondary pass (grass and shiz)...\n" );
	GenerateTerrainSectorSecondPass( pBoob, position );
	// Clean up our mess of variables
	DebugConsole::PrintMessage( "   Cleanup pass (lol bad vars)...\n" );
	GenerateTerrainSectorCleanup( pBoob );

	delete noise;
	delete noise_hf;
	delete noise_hhf;
	delete noise_lf;
	delete noise_biome;
}
// Same as previous functions, just without the large comments
void CVoxelTerrain::GenerateSingleTerrain ( CBoob * pBoob, LongIntPosition const& position )
{
	bSpreadTerrain = false;
	//DebugConsole::PrintMessage( " Generating sector..." );
	pBoob->bitinfo[0] = false;
	DebugConsole::DisableOutput();
	GenerateTerrain( pBoob, position );
	DebugConsole::EnableOutput();
	//DebugConsole::PrintMessage( "Done.\n" );
	bSpreadTerrain = true;
}

// == First Pass == 
void CVoxelTerrain::GenerateTerrainSector ( CBoob * pBoob, LongIntPosition const& position )
{
	if (( pBoob != NULL )&&( pBoob->bitinfo[3] == false ))
	{
		pBoob->bitinfo[3] = true;
		// TODO: FIX THIS SOMEDAY
		if ( bSpreadTerrain )
		{
			if ( position.z >= 0 )
				GenerateTerrainSector( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
			if ( position.x >= 0 )
				GenerateTerrainSector( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
			if ( position.y >= 0 )
				GenerateTerrainSector( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
			if ( position.z <= 0 )
				GenerateTerrainSector( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
			if ( position.x <= 0 )
				GenerateTerrainSector( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
			if ( position.y <= 0 )
				GenerateTerrainSector( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		}
		// Set position
		pBoob->position = Vector3d( ftype(position.x*64+32),ftype(position.y*64+32),ftype(position.z*64+32) );
		// Generate the terrain
		TerraGenLandscapePass( pBoob, position );
		// Put stone in the dirt
		TerraGenStonePass( pBoob, position );
		// Put dirt in the stone
		// Make caves
		TerraGenCavePass( pBoob, position );
	}
}

void CVoxelTerrain::TerraGenLandscapePass ( CBoob * pBoob, LongIntPosition const& position )
{
	// Eventually, this will become a sort of 8x sample + blend between several different generation algorithms.
	// The current algorithm is the basic test terrain algorithm. Other variations include say flatlands, mountains, and other such things.
	// Create the basic terrain
	for ( char i = 0; i < 8; i += 1 )
	{
		for ( char j = 0; j < 8; j += 1 )
		{
			for ( int k = 0; k < 512; k += 1 )
			{
				// Declared static to save init time
				static Vector3d blockPosition;

				// Get the block's noise position
				blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
				blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
				blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;

				// Get the block data
				pBoob->data[i].data[j].data[k] = TerraGen_1p_Hilllands( pBoob, blockPosition );
				//pBoob->data[i].data[j].data[k] = TerraGen_1p_Outlands( pBoob, blockPosition );
			}
		}
	}
}
ftype CVoxelTerrain::TerraGen_1p_GetElevation ( LongIntPosition const& )
{
	return 0.02f;
}

// Terrain types
char CVoxelTerrain::TerraGen_1p_Flatlands ( CBoob * pBoob, Vector3d const& blockPosition )
{
	static ftype val;
	val = noise->Get3D(blockPosition.x,blockPosition.y,blockPosition.z);
	if ( val > blockPosition.z*4.8f ) //5-6 grass lands, 0.2 outlands
		return EB_DIRT;
	else
		return EB_NONE;
}
char CVoxelTerrain::TerraGen_1p_Outlands ( CBoob * pBoob, Vector3d const& blockPosition )
{
	static ftype val;
	val = noise->Get3D(blockPosition.x,blockPosition.y,blockPosition.z);
	if ( val > blockPosition.z*0.2f ) //5-6 grass lands, 0.2 outlands
		return EB_DIRT;
	else
		return EB_NONE;
}
char CVoxelTerrain::TerraGen_1p_Hilllands ( CBoob * pBoob, Vector3d const& blockPosition )
{
	static ftype val;
	val = noise->Get3D(blockPosition.x,blockPosition.y,blockPosition.z);
	if ( val > blockPosition.z*1.04f ) //5-6 grass lands, 0.2 outlands
		return EB_DIRT;
	else
		return EB_NONE;
}

// After creating terrain, switch to stone
void CVoxelTerrain::TerraGenStonePass ( CBoob * pBoob, LongIntPosition const& position )
{
	for ( char i = 0; i < 8; i += 1 )
	{
		for ( char j = 0; j < 8; j += 1 )
		{
			for ( int k = 0; k < 512; k += 1 )
			{
				// Declared static to save init time
				static Vector3d blockPosition;
				static ftype fMainTer;
				static ftype fSubTer;

				if ( pBoob->data[i].data[j].data[k] != EB_NONE )
				{
					blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
					blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
					blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;

					fMainTer = noise->Get3D( blockPosition.x,blockPosition.y,blockPosition.z );
					fSubTer = noise_hf->Get3D( blockPosition.x,blockPosition.y,blockPosition.z );
					if ( fMainTer > blockPosition.z*1.7f+0.24f+fSubTer*0.42f )
						pBoob->data[i].data[j].data[k] = EB_STONE;
				}
			}
		}
	}
}

// Cave generation
void CVoxelTerrain::TerraGenCavePass ( CBoob * pBoob, LongIntPosition const& position )
{
	for ( char i = -2; i <= 2; i++ )
		for ( char j = -2; j <= 2; j++ )
			for ( char k = -2; k <= 2; k++ )
				TerraGen_Caves_CreateSystems( LongIntPosition( position.x+i,position.y+j,position.z+k ) );
	//TerraGen_Caves_CreateSystems( pBoob, position );
	TerraGen_Caves_ExcavateCaves( pBoob, position );
}

void CVoxelTerrain::TerraGen_Caves_CreateSystems ( LongIntPosition const& position )
{
	// Todo: For loop in the 5x5 area of the boob

	// Grab density of the boob
	static ftype density;
	
	density = 0.5f;
	density *= 0.63f;
	
	// Grab random value based on position
	static ftype fMainTer;
	fMainTer = noise->Get3D( position.x*3.9f,position.y*3.9f,position.z*4.1f )+0.5f;

	// If the boob contains the main elevation line
	static ftype elevationLine;
	elevationLine = TerraGen_1p_GetElevation( position );
	if (( (ftype)position.z >= elevationLine )&&( (ftype)position.z <= elevationLine+1.3f ))
	{
		// If the boob is underground, create a cave system with a smaller random chance
		if ( fMainTer < density*0.54f )
		{
			TerraGen_Caves_StartSystem( position );
		}
	}
	else if ( (ftype)position.z < elevationLine ) // Else if the boob is underground
	{
		// If the boob is underground, create a cave system with a random chance
		if ( fMainTer < density )
		{
			TerraGen_Caves_StartSystem( position );
		}
	}
}
// Start a system if it doesn't exist, and generate it all the way
void CVoxelTerrain::TerraGen_Caves_StartSystem ( LongIntPosition const& position )
{
	// First check if a system already exists in the generation list for this section
	for ( vector<TerraCave*>::iterator it = vCaveSystems.begin(); it != vCaveSystems.end(); it++ )
	{
		//if (( (*it)->startPosition.x == position.x )&&( (*it)->startPosition.y == position.y )&&( (*it)->startPosition.z == position.z ))
		if ( (*it)->startPosition == position )
		{
			// If it does exist, then stop now. Don't generate a thang.
			return;
		}
	}

	// If we're still here, then we can generate caves.
	TerraCave* newCave = new TerraCave;
	newCave->startPosition = position;

	// Start with an initial cave segment in a random position
	TerraTunnel newSegment;
	newSegment.ray.pos = Vector3d(
		noise_hf->Get3D( position.x*0.6f, position.y*0.7f-0.3f, position.z*0.8f )+0.5f+ftype(position.x),
		noise_hf->Get3D( position.y*0.6f, position.z*0.7f-0.3f, position.x*0.8f )+0.5f+ftype(position.y),
		noise_hf->Get3D( position.z*0.6f, position.x*0.7f-0.3f, position.y*0.8f )+0.5f+ftype(position.z)
	);
	// With a random height from radius 1.5 to 2.9
	newSegment.height = 2.2f + 1.4f*noise_hf->Get3D( position.x*1.3f+0.4f,position.z*1.6f,position.y*1.4f );
	// With a random width from radius 1.0 to 3.0
	newSegment.width = 2.0f + 2.0f*noise_hf->Get3D( position.x*1.7f-0.4f,position.z*1.2f-0.2f,position.y*1.6f );
	// With a random roughness from 0.0 to 0.2
	newSegment.noise = 0.1f + 0.2f*noise_hf->Get( position.x+position.y*0.2f,position.z+0.4f );
	// And a random direction from +15 degrees to -90 degrees
	newSegment.ray.dir = Vector3d(
		noise_hf->Get3D( position.y+position.z*1.3f-0.3f, position.x*1.2f+position.y+0.5f, position.x*2.3f ),
		noise_hf->Get3D( position.x+position.y*1.5f-0.2f, position.y*1.7f+position.z+0.3f, position.y*1.4f ),
		noise_hf->Get( position.y+position.z*1.3f-0.3f, position.x*1.4f+position.z+0.5f )*1.25f-0.375f
	);
	// And extend that from 10 to 50 percent of the boob width
	newSegment.ray.dir = newSegment.ray.dir.normal() * ( 0.3f + 0.4f*noise_hf->Get( position.z*0.6f, position.y*2.1f+position.x*0.7f-0.3f ) );

	// Add this current area to the affected stack
	newCave->affectedAreas.push_back( position );
	// Add this new segment to the stack
	newCave->partTree.push_back( newSegment );

	// Set the cave center
	vCurrentCaveCenter = Vector3d( ftype(position.x)+0.5f, ftype(position.y)+0.5f, ftype(position.z)+0.5f );

	// Recursively create the cave
	TerraGen_Caves_Generate( newCave, 0 );

	// Add all effected areas to the affected stack
	LongIntPosition currentPos;//, nextPos;
	//bool found;
	/*for ( vector<TerraTunnel>::iterator it = newCave->partTree.begin(); it != newCave->partTree.end(); it++ )
	{
		found = false;
		currentPos = BoobSpaceToIndex( it->ray.pos + it->ray.dir );
		// Search through all the affected areas
		vector<LongIntPosition>::iterator pos_it = find( newCave->affectedAreas.begin(), newCave->affectedAreas.end(), currentPos );
		// Add if not found
		if ( pos_it == newCave->affectedAreas.end() )
			newCave->affectedAreas.push_back( currentPos );
	}*/
	for ( unsigned int i = 0; i < newCave->partTree.size(); i++ )
	{
		newCave->affectionMap.push_back( new vector<LongIntPosition> () );

		currentPos = BoobSpaceToIndex( newCave->partTree[i].ray.pos );
		//newCave->affectionMap[i]->push_back( currentPos );
		currentPos = BoobSpaceToIndex( newCave->partTree[i].ray.pos + newCave->partTree[i].ray.dir );
		//newCave->affectionMap[i]->push_back( currentPos );

		// Search through all the affected areas
		vector<LongIntPosition>::iterator pos_it = find( newCave->affectedAreas.begin(), newCave->affectedAreas.end(), currentPos );
		// Add if not found
		if ( pos_it == newCave->affectedAreas.end() )
			newCave->affectedAreas.push_back( currentPos );
	}
	

	// Add our now-completed cave to the pile
	vCaveSystems.push_back( newCave );
}

// turn/end if 2 from the center point. Center point = cavecenter+Vector3d(0.5,0.5,0.5)
void CVoxelTerrain::TerraGen_Caves_Generate( TerraCave* pCave, const unsigned int iTunnel, const unsigned int seed )
{
	ftype fSeed = seed*2.3f+iTunnel*2.4f;

	// Get the previous tunnel
	TerraTunnel prevSegment = pCave->partTree[iTunnel];
	
	// Make a new tunnel
	TerraTunnel newSegment;
	newSegment.ray.pos = prevSegment.ray.pos + prevSegment.ray.dir;

	// If the previous index is even, then we want to go horizontal or slightly down
	if ( iTunnel % 2 == 0 )
	{
		// Choose a random direction that's related to the current direction
		newSegment.ray.dir.x = 2.0f * noise->Get( pCave->startPosition.z*1.2f+newSegment.ray.pos.x-0.4f,  pCave->startPosition.y * 1.2f + prevSegment.ray.pos.y - iTunnel*1.8f );
		newSegment.ray.dir.y = 2.0f * noise->Get( pCave->startPosition.z*1.3f+newSegment.ray.pos.y-0.5f,  pCave->startPosition.x * 1.3f + prevSegment.ray.pos.x - iTunnel*1.7f );

		newSegment.ray.dir += prevSegment.ray.dir.normal()*0.4f;
		newSegment.ray.dir.z *= 0.03f;

		// So randomly go horizontal or down
		if ( noise->Get( iTunnel*0.7f, pCave->startPosition.x * 1.2f ) > 0.0f )
			newSegment.ray.dir.z = -0.1f + 0.2f+noise->Get( pCave->startPosition.x*1.2f+iTunnel*0.8f-0.4f,  pCave->startPosition.z * 1.2f + prevSegment.ray.pos.y );

		// Normalize it and extend it from 10 to 30 percent of the boob width
		newSegment.ray.dir = newSegment.ray.dir.normal() * ( 0.2f + 0.2f*noise_hf->Get( newSegment.ray.pos.z*0.7f+0.2f, newSegment.ray.pos.y*2.2f+newSegment.ray.pos.x*0.6f-0.7f ) );

		// Now make sure the ending position is in the boob area
		Vector3d endPos = newSegment.ray.pos + newSegment.ray.dir;
		if (( fabs( endPos.x-vCurrentCaveCenter.x ) < 1.7f )&&( fabs( endPos.y-vCurrentCaveCenter.y ) < 1.7f )&&( fabs( endPos.z-vCurrentCaveCenter.z ) < 1.7f ))
		{
			// If it's in the area, then we can continue generation and add this tunnel.

			// With a random height from the previous segment, limited at 1.5 and 5.0
			newSegment.height = prevSegment.height + 1.4f*noise_hf->Get3D( endPos.x*1.3f+0.4f,endPos.z*1.6f,endPos.y*1.4f );
			newSegment.height = max( 1.5f, min( 5.0f, newSegment.height ) );
			// With a random width from the previous segment, limited at 1.0 and 6.0
			newSegment.width = prevSegment.width + 2.0f*noise_hf->Get3D( endPos.x*1.7f-0.4f,endPos.z*1.2f-0.2f,endPos.y*1.6f );
			newSegment.width = max( 1.0f, min( 6.0f, newSegment.width ) );
			// With a random roughness from the previous segment, limited at 0.0 and 0.5
			newSegment.noise = prevSegment.noise + 0.2f*noise_hf->Get( endPos.x+endPos.y*0.2f,endPos.z+0.4f );
			newSegment.noise = max( 0.0f, min( 0.5f, newSegment.noise ) );

			// Add the tunnel to the list and continue generating
			pCave->partTree.push_back( newSegment );
			TerraGen_Caves_Generate( pCave, pCave->partTree.size()-1, seed );
		}
	}
	// If the previous index is odd, then we want to go horizontal, directly downwards, directly upwards, or split
	else
	{
		// Choose a type of generation
		ftype randomVal = noise_hf->Get3D( fSeed*2.1f-newSegment.ray.pos.x*0.8f+0.2f,newSegment.ray.pos.z*0.8f,newSegment.ray.pos.y*0.8f-fSeed*0.4f );

		// Do a horizontal tunnel
		if (( randomVal > -0.15f )||(( randomVal < -0.2 )&&( pCave->partTree.size() > 20 )))
		{
			// Choose a random direction that's related to the current direction
			newSegment.ray.dir.x = 2.0f * noise->Get( pCave->startPosition.z*1.2f+newSegment.ray.pos.x-0.4f,  pCave->startPosition.y * 1.2f + prevSegment.ray.pos.y - fSeed*1.8f );
			newSegment.ray.dir.y = 2.0f * noise->Get( pCave->startPosition.z*1.3f+newSegment.ray.pos.y-0.5f,  pCave->startPosition.x * 1.3f + prevSegment.ray.pos.x - fSeed*1.7f );

			newSegment.ray.dir += prevSegment.ray.dir.normal();
			newSegment.ray.dir.z *= 0.03f;

			// So randomly go horizontal or down
			if ( noise->Get( iTunnel*0.7f, pCave->startPosition.x * 1.2f ) > 0.0f )
				newSegment.ray.dir.z = -0.1f + 0.2f+noise->Get( pCave->startPosition.x*1.2f+iTunnel*0.8f-0.4f,  pCave->startPosition.z * 1.2f + prevSegment.ray.pos.y );

			// Normalize it and extend it from 10 to 30 percent of the boob width
			newSegment.ray.dir = newSegment.ray.dir.normal() * ( 0.2f + 0.2f*noise_hf->Get( newSegment.ray.pos.z*0.7f+0.2f, newSegment.ray.pos.y*2.2f+newSegment.ray.pos.x*0.6f-0.7f ) );
		}
		// Do a tunnel split
		else if ( randomVal < -0.2f )
		{
			// Choose a random direction that's related to the current direction
			newSegment.ray.dir.x = 2.0f * noise->Get( pCave->startPosition.z*1.2f+newSegment.ray.pos.x-0.4f,  pCave->startPosition.y * 1.2f + prevSegment.ray.pos.y - fSeed*1.8f );
			newSegment.ray.dir.y = 2.0f * noise->Get( pCave->startPosition.z*1.3f+newSegment.ray.pos.y-0.5f,  pCave->startPosition.x * 1.3f + prevSegment.ray.pos.x - fSeed*1.7f );

			newSegment.ray.dir += prevSegment.ray.dir.normal()*0.2f;
			newSegment.ray.dir.z *= 0.03f;

			// So randomly go horizontal or down
			if ( noise->Get( iTunnel*0.7f, pCave->startPosition.x * 1.2f ) > 0.0f )
				newSegment.ray.dir.z = -0.1f + 0.2f+noise->Get( pCave->startPosition.x*1.2f+iTunnel*0.8f-0.4f,  pCave->startPosition.z * 1.2f + prevSegment.ray.pos.y );

			// Normalize it and extend it from 10 to 30 percent of the boob width
			newSegment.ray.dir = newSegment.ray.dir.normal() * ( 0.2f + 0.2f*noise_hf->Get( newSegment.ray.pos.z*0.7f+0.2f, newSegment.ray.pos.y*2.2f+newSegment.ray.pos.x*0.6f-0.7f ) );

			// Also do another expansion
			TerraGen_Caves_Generate( pCave, iTunnel, seed+1 );
		}
		// Do a vertical up or down spike
		else
		{
			// Choose a random direction that's related to the current direction
			newSegment.ray.dir.x = 2.0f * noise->Get( pCave->startPosition.z*1.2f+newSegment.ray.pos.x-0.4f,  pCave->startPosition.y * 1.2f + prevSegment.ray.pos.y - fSeed*1.8f );
			newSegment.ray.dir.y = 2.0f * noise->Get( pCave->startPosition.z*1.3f+newSegment.ray.pos.y-0.5f,  pCave->startPosition.x * 1.3f + prevSegment.ray.pos.x - fSeed*1.7f );

			newSegment.ray.dir += prevSegment.ray.dir.normal();
			newSegment.ray.dir.z *= 0.03f;

			// So randomly go down -10 to -40
			newSegment.ray.dir.z = -25.0f + 30.0f*noise_hf->Get( pCave->startPosition.x*1.3f+iTunnel*0.9f+0.4f,  pCave->startPosition.z * 1.3f + prevSegment.ray.pos.y );

			// Randomly flip it
			//if ( noise->Get( iTunnel*0.7f, pCave->startPosition.x * 1.2f ) > 0.3f )
			//	newSegment.ray.dir.z *= -1;

			// Normalize it and extend it from 30 to 120 percent of the boob width
			// 30 to 120 = 0.75 + 0.9
			// 30 to 90 = 0.6 + 0.6
			newSegment.ray.dir = newSegment.ray.dir.normal() * ( 0.6f + 0.6f*noise_hf->Get( newSegment.ray.pos.z*0.7f+0.2f+fSeed*2.1f, newSegment.ray.pos.y*2.2f+newSegment.ray.pos.x*0.6f-0.7f-fSeed*2.1f ) );
		}

		// Now make sure the ending position is in the boob area
		Vector3d endPos = newSegment.ray.pos + newSegment.ray.dir;
		if (( fabs( endPos.x-vCurrentCaveCenter.x ) < 1.7f )&&( fabs( endPos.y-vCurrentCaveCenter.y ) < 1.7f )&&( fabs( endPos.z-vCurrentCaveCenter.z ) < 1.7f ))
		{
			// If it's in the area, then we can continue generation and add this tunnel.

			// With a random height from the previous segment, limited at 1.5 and 5.0
			newSegment.height = prevSegment.height + 1.4f*noise_hf->Get3D( endPos.x*1.3f+0.4f,endPos.z*1.6f,endPos.y*1.4f );
			newSegment.height = max( 1.5f, min( 5.0f, newSegment.height ) );
			// With a random width from the previous segment, limited at 1.0 and 6.0
			newSegment.width = prevSegment.width + 2.0f*noise_hf->Get3D( endPos.x*1.7f-0.4f,endPos.z*1.2f-0.2f,endPos.y*1.6f );
			newSegment.width = max( 1.0f, min( 6.0f, newSegment.width ) );
			// With a random roughness from the previous segment, limited at 0.0 and 0.5
			newSegment.noise = prevSegment.noise + 0.2f*noise_hf->Get( endPos.x+endPos.y*0.2f,endPos.z+0.4f );
			newSegment.noise = max( 0.0f, min( 0.5f, newSegment.noise ) );

			// Add the tunnel to the list and continue generating
			pCave->partTree.push_back( newSegment );
			TerraGen_Caves_Generate( pCave, pCave->partTree.size()-1, seed );
		}
	}
}

void CVoxelTerrain::TerraGen_Caves_ExcavateCaves ( CBoob * pBoob, LongIntPosition const& position )
{
	for ( char i = 0; i < 8; i += 1 )
	{
		for ( char j = 0; j < 8; j += 1 )
		{
			for ( int k = 0; k < 512; k += 1 )
			{
				// Declared static to save init time
				static Vector3d blockPosition;
				static ftype fMainTer;
				static ftype fSubTer;

				/*if ( pBoob->data[i].data[j].data[k] != EB_NONE )
				{
					blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
					blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
					blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;

					fMainTer = noise->Get3D( blockPosition.x,blockPosition.y,blockPosition.z );
					fSubTer = noise_hf->Get3D( blockPosition.x,blockPosition.y,blockPosition.z );
					if ( fMainTer > blockPosition.z*1.7f+0.24f+fSubTer*0.42f )
						pBoob->data[i].data[j].data[k] = EB_STONE;
				}*/

				//fMainTer = noise->Get3D( blockPosition.x*0.8f,blockPosition.y*0.8f,blockPosition.z*1.1f );
				/*fMainTer = noise->Get3D( blockPosition.x*1.2f,blockPosition.y*1.2f,blockPosition.z*1.7f );
				//fMainTer = noise->Get3D( blockPosition.x*0.4f,blockPosition.y*0.4f,blockPosition.z*0.7f ); // Big, wide caverms
				fMainTer = (fMainTer+0.5f);
				//if ( fMainTer*fMainTer < 0.01f )
				//if ( fabs(fMainTer-0.5f) < 0.1f )
				//if ( fMainTer*fMainTer > 0.9f )
				//if ( fabs((fMainTer*fMainTer)-0.6f) < 0.07f )
				//if ( fMainTer*fMainTer > 0.8f )
				
				//if ( fabs(fMainTer*fMainTer - 0.6f) > 0.46f ) // Big, wide caverns
				if ( fabs(fMainTer - 0.6f) > 0.46f ) // Big, wide caverns
					pBoob->data[i].data[j].data[k] = EB_STONE;*/

				blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
				blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
				blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;

				//fMainTer = noise->Get3D( blockPosition.x,blockPosition.y,blockPosition.z );
				/*if ( fMainTer < max(blockPosition.z,-0.4) )
					pBoob->data[i].data[j].data[k] = EB_NONE;*/

				if ( pBoob->data[i].data[j].data[k] != EB_NONE )
				{
					// Loop through all the caves.
					for ( vector<TerraCave*>::iterator it = vCaveSystems.begin(); it != vCaveSystems.end(); it++ )
					{
						// Look for this current boob index
						vector<LongIntPosition>::iterator searchResult = find( (*it)->affectedAreas.begin(), (*it)->affectedAreas.end(), position );

						// If it can be affected
						if ( searchResult != (*it)->affectedAreas.end() )
						{
							// Then excavate each tunnel
							/*for ( vector<TerraTunnel>::iterator itt = (*it)->partTree.begin(); itt != (*it)->partTree.end(); itt++ )
							{
								Vector3d a_to_p = blockPosition-(itt->ray.pos);
								Vector3d a_to_b = itt->ray.dir;

								ftype atb2 = a_to_b.sqrMagnitude();
								ftype atp_dot_atb = a_to_p.dot( a_to_b );

								ftype t = min( 1.0f, max( 0.0f, atp_dot_atb / atb2  ) );

								Vector3d pos = itt->ray.pos + a_to_b*t;

								// If the distance is close enough, then bam, excavate
								if ( (pos-blockPosition).magnitude() <= (itt->height/32.0f) )
								{
									pBoob->data[i].data[j].data[k] = EB_NONE;
								}
							}
							// End tunnel for loop*/
							// Then for each tunnel
							//for ( vector<TerraTunnel>::iterator itt = (*it)->partTree.begin(); itt != (*it)->partTree.end(); itt++ )
							for ( unsigned int i = 0; i < (*it)->partTree.size(); i++ )
							{
								// If this current boob is in the tunnel edited
								vector<LongIntPosition>::iterator searchResult2 = find( (*it)->affectionMap[i]->begin(), (*it)->affectionMap[i]->end(), position );

								if ( searchResult2 != (*it)->affectionMap[i]->end() )
								{
									TerraTunnel const& tunnelRef = (*it)->partTree[i];

									Vector3d a_to_p = blockPosition-(tunnelRef.ray.pos);
									Vector3d a_to_b = tunnelRef.ray.dir;

									ftype atb2 = a_to_b.sqrMagnitude();
									ftype atp_dot_atb = a_to_p.dot( a_to_b );

									ftype t = min( 1.0f, max( 0.0f, atp_dot_atb / atb2  ) );

									Vector3d pos = tunnelRef.ray.pos + a_to_b*t;

									// If the distance is close enough, then bam, excavate
									if ( (pos-blockPosition).magnitude() <= (tunnelRef.height/32.0f) )
									{
										pBoob->data[i].data[j].data[k] = EB_NONE;
									}
								}
							}
							// End tunnel for loop
						}
					}
					// End cavern for loop
				}
			}
		}
	}
}

// == Second Pass ==
void CVoxelTerrain::GenerateTerrainSectorSecondPass ( CBoob * pBoob, LongIntPosition const& position )
{
	if (( pBoob != NULL )&&( pBoob->bitinfo[0] == false ))
	{
		pBoob->bitinfo[0] = true;
		// TODO: FIX THIS SOMEDAY
		if ( bSpreadTerrain )
		{
			if ( position.z >= 0 )
				GenerateTerrainSectorSecondPass( pBoob->top, LongIntPosition( position.x, position.y, position.z+1 ) );
			if ( position.x >= 0 )
				GenerateTerrainSectorSecondPass( pBoob->front, LongIntPosition( position.x+1, position.y, position.z ) );
			if ( position.y >= 0 )
				GenerateTerrainSectorSecondPass( pBoob->left, LongIntPosition( position.x, position.y+1, position.z ) );
			if ( position.z <= 0 )
				GenerateTerrainSectorSecondPass( pBoob->bottom, LongIntPosition( position.x, position.y, position.z-1 ) );
			if ( position.x <= 0 )
				GenerateTerrainSectorSecondPass( pBoob->back, LongIntPosition( position.x-1, position.y, position.z ) );
			if ( position.y <= 0 )
				GenerateTerrainSectorSecondPass( pBoob->right, LongIntPosition( position.x, position.y-1, position.z ) );
		}
		// Set position
		//pBoob->position = Vector3d( ftype(position.x*64+32),ftype(position.y*64+32),ftype(position.z*64+32) );
		// Generate the grass, small details, and liquids
		TerraGenGrassPass( pBoob, position );
		TerraGenTreePass ( pBoob, position );
	}
}

// Generate grass
void CVoxelTerrain::TerraGenGrassPass ( CBoob * pBoob, LongIntPosition const& position )
{
	for ( char i = 0; i < 8; i += 1 )
	{
		for ( char j = 0; j < 8; j += 1 )
		{
			for ( int k = 0; k < 512; k += 1 )
			{
				// Declared static to save init time
				static Vector3d blockPosition = Vector3d( 0,0,0 );
				static ftype val;
				
				if ( pBoob->data[i].data[j].data[k] == EB_DIRT )
				{
					if ( SideVisible( pBoob, i,j, (char*)pBoob->data[i].data[j].data, k, 8, TOP, 1, blockPosition ) )
					{
						blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
						blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
						blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;
						val = noise_hf->Get3D(blockPosition.z,blockPosition.x,blockPosition.y);
						if ( val < blockPosition.z*2.4f+0.4f )
							pBoob->data[i].data[j].data[k] = EB_GRASS;
					}
				}	
			}
		}
	}
}
// Generate trees
void CVoxelTerrain::TerraGenTreePass ( CBoob * pBoob, LongIntPosition const& position )
{
	for ( char i = 0; i < 8; i += 1 )
	{
		for ( char j = 0; j < 8; j += 1 )
		{
			for ( int k = 0; k < 512; k += 1 )
			{
				// Declared static to save init time
				static Vector3d blockPosition = Vector3d( 0,0,0 );
				static ftype val;
				static ftype val2;
				
				if ( pBoob->data[i].data[j].data[k] == EB_GRASS )
				{
					if ( SideVisible( pBoob, i,j, (char*)pBoob->data[i].data[j].data, k, 8, TOP, 1, blockPosition ) )
					{
						blockPosition.x = position.x + (((i%2) * 16) + ((j%2) * 8) + (k%8))/32.0f;
						blockPosition.y = position.y + ((((i/2)%2) * 16) + (((j/2)%2) * 8) + ((k/8)%8))/32.0f;
						blockPosition.z = position.z + (((i/4) * 16) + ((j/4) * 8)  + (k/64))/32.0f;
						val2 = noise_hhf->Get3D(blockPosition.x,blockPosition.y,blockPosition.z) * 1.8f;
						val = noise_hf->Get3D(blockPosition.z,blockPosition.x,blockPosition.y)*0.9f + val2*val2*val2;
						/*if ( val < blockPosition.z*2.4f+0.4f )
						{
							pBoob->data[i].data[j].data[k] = EB_GRASS;*/
						//if ( val < blockPosition.z )
						if ( val > 0.6 )
						{
							//CFoliageTree* pNewTree = new CFoliageTree();
							CTreeBase* pNewTree = new CTreeBase();
							pNewTree->transform.position = blockPosition * 64.0f + Vector3d( 1,1,2 );
							//pNewTree->transform.rotation.z = val*360.0f;
							//pNewTree->transform.scale = Vector3d( 1,1,1 ) * ( 0.12f + val*0.03f );
							pNewTree->Generate();
							//pNewTree->RemoveReference();
							pBoob->v_foliage.push_back( pNewTree );

						}
					}
				}	
			}
		}
	}
}

void CVoxelTerrain::GenerateTerrainSectorCleanup ( CBoob * pBoob )
{
	if (( pBoob != NULL )&&( pBoob->bitinfo[0] == true ))
	{
		pBoob->bitinfo[0] = false;

		// Boob now has data
		pBoob->hasData = true;

		if ( bSpreadTerrain )
		{
			// TODO: FIX THIS SOMEDAY
			GenerateTerrainSectorCleanup( pBoob->top );
			GenerateTerrainSectorCleanup( pBoob->front );
			GenerateTerrainSectorCleanup( pBoob->left );
			GenerateTerrainSectorCleanup( pBoob->bottom );
			GenerateTerrainSectorCleanup( pBoob->back );
			GenerateTerrainSectorCleanup( pBoob->right );
		}
	}
}