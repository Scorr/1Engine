#version 140

//#define USE_REFLECTSPECULAR

// Inputs from vertex shader
varying vec4 v2f_normals;
varying vec4 v2f_colors;
varying vec4 v2f_position;
varying vec2 v2f_texcoord0;
varying float v2f_fogdensity;

// Samplers
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1; // Inverse alpha mask (generated by engine)
uniform sampler2D textureSampler2; // Fademap
uniform sampler2D textureSampler3; // Tattoo map (note that 0.5rgb is fullwhite. above 0.5rgb is used as glowmap)
uniform samplerCube textureSampler4; // test cube shiet!

// System Inputs
uniform vec4 sys_DiffuseColor;
uniform vec3 sys_EmissiveColor;

uniform vec3 sys_WorldCameraPos;
//uniform vec4 sys_SinTime, sys_CosTime;

varying vec4 v2f_lightcoord[8];
varying vec3 v2f_screenpos;
// Lighting and Shadows
uniform vec4 sys_LightAmbient;
layout(std140) uniform sys_LightingInfo
{
	vec4 sys_LightColor[8];
	vec4 sys_LightPosition[8];
	vec4 sys_LightProperties[8];
	vec4 sys_LightShadowInfo[8];
	mat4 sys_LightMatrix[8];
};
uniform sampler2D textureShadow0;
uniform sampler2D textureShadow1;
uniform sampler2D textureShadow2;

// World Reflection
#ifdef USE_REFLECTSPECULAR
layout(std140) uniform sys_ReflectInfo
{
	vec4 sys_ReflectMinBox;
	vec4 sys_ReflectMaxBox;
	vec4 sys_ReflectSource;
};
uniform samplerCube textureReflection0; // World Reflection
#endif

// Game Inputs
uniform float	gm_FadeValue = 1;
uniform float	gm_HalfScale = 0.5;

// Fog
layout(std140) uniform sys_Fog
{
	vec4	sys_FogColor;
	float 	sys_FogEnd;
	float 	sys_FogScale;
};

float cellShade ( float lumin )
{
	const int levels = 2;
	float t = lumin*levels;
	float dif = 0.5 - mod(t+0.5,1);
	t += dif * min(1,(0.5-abs(dif))*32) * 0.5;
	
	lumin = t/levels;
	/*const float minval = 0.3;
	if ( lumin < -minval ) {
		lumin = -minval;
	}
	if ( lumin < minval ) {
		lumin = minval*((lumin+minval)/(minval*2));
	}*/
	return lumin;
}
// Sine wave appoximation method (benchmarked to about 3% speed increase over all shadows)
float SmoothCurve( float x ) {  
	return x * x *( 3.0 - 2.0 * x );  
}  
float TriangleWave( float x ) {  
	return abs( fract( x + 0.5 ) * 2.0 - 1.0 );  
}  
float SmoothTriangleWave( float x ) {  
	return (SmoothCurve( TriangleWave( x ) ))*2 - 1;  
} 
vec2 random ( vec3 seed3 )
{
	float dot_product = dot(seed3, vec3(12.9898,78.233,45.164));
	dot_product = SmoothTriangleWave(dot_product);
    return vec2( fract(dot_product * 43758.5453), fract(dot_product * 35362.2151) );
}

float diffuseLighting ( vec3 normal, vec3 lightDist, float lightRange, float lightFalloff, float lightPass, float mixthrough )
{
	// Distance-based attenuation
	float attenuation = pow( max( 1.0 - (length( lightDist )*lightRange), 0.0 ), lightFalloff );
	
	//Cosine law * attenuation
	float normalAttenuate = dot( normal,normalize( lightDist ) );
	normalAttenuate = (max( normalAttenuate, -mixthrough ) + mixthrough)/(1+mixthrough);
	// hard step passthrough
	float color = mix( normalAttenuate, 1.0, lightPass*(1.0+attenuation) ) * attenuation;
	
	// Return final color
	return (color);
}
float specularLighting( vec3 normal, vec3 lightdir, vec3 viewdir, float specular_pow, float lightRange )
{ //TODO: DISTANCE ATTENUATION
	// Create the reflection vector
	vec3 reflectdir = 2*dot(normal,lightdir)*normalize(normal) - normalize(lightdir);
	// Attenuation is based on camera position and reflection dir
	float attenuation = max( dot( normalize(reflectdir), normalize(viewdir) ), 0.0 );
	// Also add distance-based attenuation though
	float distance_attenuation = max( 1.0 - (length( lightdir )*lightRange*0.4), 0.0 );
	
	//return pow( attenuation, specular_pow );
	return pow( attenuation*distance_attenuation, specular_pow+((1.0-distance_attenuation)*2.0) );
}

vec3 defaultLighting ( vec4 lightPosition, vec4 lightProperties, vec4 lightColor, vec3 vertDir, in float lightVal3, in float mixthrough, in float rimStrength )
{
	vec3 resultColor;
	{
		vec3 lightDir = lightPosition.xyz - v2f_position.xyz;
		
		// Diffuse lighting
		float lightVal1 = diffuseLighting(
			v2f_normals.xyz, lightDir,
			lightProperties.x, lightProperties.y, lightProperties.z,
			mixthrough
			);
		float lightVal2 = dot( lightPosition.xyz, v2f_normals.xyz );
		lightVal2 = (max( lightVal2, -mixthrough ) + mixthrough)/(1+mixthrough);
		
		lightVal1 = cellShade(lightVal1);
		lightVal2 = cellShade(lightVal2);
		
		lightVal1 += (lightVal1) * lightVal3 * 1.3;
		lightVal2 += (lightVal2) * lightVal3 * 1.3;
		
		// Backside lighting (vec3(1.0,0.6,0.7))
		float backLight2 = max( dot( lightPosition.xyz, -v2f_normals.xyz ), 0 );
		
		// Rim lighting
		rimStrength += mix( length(lightVal2*lightColor.rgb), length(lightVal1*lightColor.rgb), lightPosition.w )*0.25;
		rimStrength = min( 1, rimStrength );
		
		// Specular lighting
#ifndef USE_REFLECTSPECULAR
		float specLight1 = specularLighting( v2f_normals.xyz, lightDir, vertDir, 4, lightProperties.x ) * 0.3;
		float specLight2 = specularLighting( v2f_normals.xyz, lightPosition.xyz, vertDir, 4, 0 ) * 0.3; 

		float specLight_b_val = length(sys_EmissiveColor)*0.7 + 0.2 + lightVal3;
		float specLight1_b = specularLighting( v2f_normals.xyz, lightDir, vertDir, 28, lightProperties.x ) * specLight_b_val;
		float specLight2_b = specularLighting( v2f_normals.xyz, lightPosition.xyz, vertDir, 28, 0 ) * specLight_b_val;
		
		resultColor = lightColor.rgb * mix(
			lightVal2*0.9+specLight2+specLight2_b,
			lightVal1*0.9+specLight1+specLight1_b,
			lightPosition.w );
#else
		resultColor = lightColor.rgb * mix(
			lightVal2,
			lightVal1,
			lightPosition.w );
#endif
		resultColor += lightColor.rgb * vec3(1.0,0.5,0.6) * backLight2*(1-v2f_colors.g)*3 * (1-lightPosition.w);
	}
	return resultColor;
}
float shadowCalculate ( /*vec4 lightCoords,*/ vec4 shadowInfo, sampler2D textureShadow )
{
	float shadowDist = 1.0;
	// Generate texture coords
	vec4 shadowWcoord3 = v2f_lightcoord[0];
	shadowWcoord3.xyz /= shadowWcoord3.w;
	vec4 shadowWcoord2 = v2f_lightcoord[1];
	shadowWcoord2.xyz /= shadowWcoord2.w;	
	vec4 shadowWcoord1 = v2f_lightcoord[2];
	shadowWcoord1.xyz /= shadowWcoord1.w;
	vec4 shadowWcoord0 = v2f_lightcoord[3];
	shadowWcoord0.xyz /= shadowWcoord0.w;
	vec2 minCoords;
	// Get rid of the non-uniformity. Always sample shadows.
	{
		const float cspd = 0.98; // Cascade padding value
					
		float depthDifference = 0.0;
		float distanceFromLight;
		vec3 coord; 
		float bias = 0;
		for ( int i = 0; i < 4; i += 1 )
		{
			coord.xy = random( vec3(v2f_screenpos.xy,i) ).xy*(1-cspd)*0.12;
			coord.z = 0;
			coord.xy += vec2( SmoothTriangleWave(i*0.25),SmoothTriangleWave(i*0.25+0.25) )*(1-cspd)*0.12;
		
			if ( (abs(shadowWcoord0.x-0.5) < 0.5*cspd) && (abs(shadowWcoord0.y-0.5) < 0.5*cspd) )
			{
				coord += shadowWcoord0.xyz;
				coord.x = coord.x*0.25 + 0.75;
				bias = 0.02;
			}
			else if ( (abs(shadowWcoord1.x-0.5) < 0.5*cspd) && (abs(shadowWcoord1.y-0.5) < 0.5*cspd) )
			{
				coord += shadowWcoord1.xyz;
				coord.x = coord.x*0.25 + 0.50;
				bias = 0.08;
			}
			else if ( (abs(shadowWcoord2.x-0.5) < 0.5*cspd) && (abs(shadowWcoord2.y-0.5) < 0.5*cspd) )
			{
				coord += shadowWcoord2.xyz;
				coord.x = coord.x*0.25 + 0.25;
				bias = 0.64;
			}
			else //if ( abs(shadowWcoord3.x-0.5) < 0.5*cspd && abs(shadowWcoord3.y-0.5) < 0.5*cspd )
			{
				coord += shadowWcoord3.xyz;
				coord.x = coord.x*0.25;
				bias = 2.56;
			}
			
			// Limit Y coordinate
			coord.y = max( min( coord.y, 1.0 ), 0.0 );
			
			distanceFromLight = texture( textureShadow, coord.xy ).r;
			depthDifference += clamp((coord.z - distanceFromLight)*1024.0 - bias, 0.0,1.0);
		}
		depthDifference /= 4.0;
		
		minCoords = min( abs(shadowWcoord3.xy-vec2(0.5,0.5)), abs(shadowWcoord2.xy-vec2(0.5,0.5)) );
		minCoords = min( minCoords, abs(shadowWcoord1.xy-vec2(0.5,0.5)) );
		minCoords = min( minCoords, abs(shadowWcoord0.xy-vec2(0.5,0.5)) );

		// Decrease dif val if close to edge
		depthDifference *= clamp( 8.0-minCoords.x*16.0, 0.0,1.0 );
		depthDifference *= clamp( 8.0-minCoords.y*16.0, 0.0,1.0 );
		
		// Do the color mix
		shadowDist = clamp( 1.0-depthDifference, 0.0,1.0 );
	}
	// If out of range or shadows are not enabled, set shadowDist to 1
	if (( shadowInfo.x <= 0.5 )||( shadowWcoord3.z < 0.0 )||( minCoords.x > 0.5 )||( minCoords.y > 0.5 ))
	{
		shadowDist = 1.0;
	}

	return shadowDist;
}

#ifdef USE_REFLECTSPECULAR
// Box projection code shamelessly ripped from http://devlog-martinsh.blogspot.com
// because sphere projection kept giving a really drunk result
vec3 bpcem ( in vec3 n_raydir )
{
	vec3 nrdir = normalize(n_raydir);
	vec3 rbmax = (sys_ReflectMaxBox.xyz - v2f_position.xyz)/nrdir;
	vec3 rbmin = (sys_ReflectMinBox.xyz - v2f_position.xyz)/nrdir;

	vec3 rbminmax;
	rbminmax.x = (nrdir.x>0.0)?rbmax.x:rbmin.x;
	rbminmax.y = (nrdir.y>0.0)?rbmax.y:rbmin.y;
	rbminmax.z = (nrdir.z>0.0)?rbmax.z:rbmin.z;
	float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
	vec3 posonbox = v2f_position.xyz + nrdir * fa;
	return posonbox - sys_ReflectSource.xyz;
}
#endif

void main ( void )  
{
	/*vec4 fadeValue = (texture2D( textureSampler2, v2f_texcoord0 )
				   + texture2D( textureSampler2, (v2f_texcoord0*0.5)+vec2(sys_SinTime.x+1,sys_CosTime.x+1)*0.5 ))/2;*/
	vec4 fadeValue = texture2D( textureSampler2, v2f_texcoord0 );		   
	float fadeDif = fadeValue.r - (gm_FadeValue-0.17);
	if ( fadeDif < 0 ) {
		discard;
	}
	float alphaMask = 1-texture2D( textureSampler1, v2f_texcoord0 ).r;
	if ( alphaMask < 0 ) {
		discard;
	}
	
	float rimStrength = max( 0.03, min( 1, sys_LightAmbient.r+sys_LightAmbient.g+sys_LightAmbient.b - 0.4 ) );
	
	vec4 diffuseColor = texture2D( textureSampler0, v2f_texcoord0 );
	//diffuseColor.rgb = diffuseColor.rgb*0.5 + ((diffuseColor.rgb*2)-0.917)*0.5; // this line makes texture more pronounced
	diffuseColor.rgb -= (0.917-diffuseColor.rgb)*(1-sys_DiffuseColor.rgb); // this line makes texture more pronoused without mucking everything up
	vec4 tattooColor = texture2D( textureSampler3, vec2(v2f_texcoord0.x*gm_HalfScale,v2f_texcoord0.y) ) * diffuseColor;
	
	// Camera direction
	vec3 vertDir;
	vertDir = sys_WorldCameraPos-v2f_position.xyz;
	
	// Create the reflection vector and compute reflection
#ifdef USE_REFLECTSPECULAR
	vec3 pixelNormal = v2f_normals.xyz;
	vec3 pixelReflect = normalize(vertDir) - 2*dot(pixelNormal,normalize(vertDir))*normalize(pixelNormal);
	vec4 reflectionColor = texture( textureReflection0, bpcem(pixelReflect).xzy );
#endif

	// == LIGHTING ==
	vec3 lightColor = vec3(0,0,0);// = sys_EmissiveColor*rimStrength + (tattooColor.rgb-0.5)*tattooColor.a;
	const float mixthrough = 0.3;
	
	float lightVal3 = max(1-dot( v2f_normals.xyz, normalize(vertDir) ),0.0);
	// Fixed function lighting
	/*lightColor +=
		defaultLighting( sys_LightPosition[0], sys_LightProperties[0], sys_LightColor[0], vertDir, lightVal3, mixthrough, rimStrength )
		* shadowCalculate( v2f_lightcoord[0], sys_LightShadowInfo[0], textureShadow0 );*/
	lightColor +=
		defaultLighting( sys_LightPosition[0], sys_LightProperties[0], sys_LightColor[0], vertDir, lightVal3, mixthrough, rimStrength )
		* shadowCalculate( /*v2f_lightcoord[0],*/ sys_LightShadowInfo[0], textureShadow0 );
	lightColor += defaultLighting( sys_LightPosition[1], sys_LightProperties[1], sys_LightColor[1], vertDir, lightVal3, mixthrough, rimStrength );
	lightColor += defaultLighting( sys_LightPosition[2], sys_LightProperties[2], sys_LightColor[2], vertDir, lightVal3, mixthrough, rimStrength );
	lightColor += defaultLighting( sys_LightPosition[3], sys_LightProperties[3], sys_LightColor[3], vertDir, lightVal3, mixthrough, rimStrength );
	lightColor += defaultLighting( sys_LightPosition[4], sys_LightProperties[4], sys_LightColor[4], vertDir, lightVal3, mixthrough, rimStrength );
	
	vec3 preAmbientLight = lightColor;
	
	lightColor += sys_EmissiveColor*rimStrength;
	lightColor += sys_LightAmbient.rgb;
	lightColor += max(sys_DiffuseColor.rgb,vec3(0.3,0.3,0.3)) * lightVal3 * 0.16 * rimStrength;
	lightColor += sys_EmissiveColor*lightVal3*4*rimStrength;
	// Glowing tattoos. Maximize the emissive color.
	lightColor = max( lightColor, (tattooColor.rgb-0.5)*tattooColor.a*2 );
	
	// Texture and tattoo colors
	diffuseColor = diffuseColor * sys_DiffuseColor;
	float lerpValue = clamp( (length(tattooColor.rgb)-length(vec3(0.51,0.51,0.51)))*2, 0, 1 ); // Calculate color for glowing tattoos
	//float lerpValue = clamp( ((tattooColor.r+tattooColor.g+tattooColor.b)-1.5), 0, 1 );
	vec3 targetTattooColor = min(vec3(1,1,1), mix( tattooColor.rgb*2, (tattooColor.rgb-0.5)+diffuseColor.rgb, lerpValue ) );
	diffuseColor.rgb += ( targetTattooColor - diffuseColor.rgb)*tattooColor.a; // Glowing tattoos don't make diffuse go over 1
	// Shadow "outline" effect
	diffuseColor.rgb *= 1-(clamp( (pow( clamp(lightVal3,0,1), 5 )-0.12)/0.1, 0,1 ) * (1-min(0.7,length(preAmbientLight)*4)))*0.6;
	
	// Add reflection to the skin
#ifdef USE_REFLECTSPECULAR
	lightColor += pow(reflectionColor.rgb,vec3(2,2,2)) * (preAmbientLight+max(length(reflectionColor)*0.3-0.2,0));
#endif

	gl_FragColor = mix( sys_FogColor, diffuseColor * vec4( lightColor, 1.0 ), v2f_fogdensity );
	
	float _lerpVal = (1-min(1,fadeDif/0.17));
	gl_FragColor.rgb = gl_FragColor.rgb*(1-_lerpVal) +  vec3(0.7,0.8,0.9)*_lerpVal;
	//gl_FragColor.rgb = gl_FragColor.rgb*0.01 + v2f_colors.rgb*0.99;
	//gl_FragColor.rgb = vec3(1,1,1) * lightVal3; //rim debugging
	gl_FragColor.a = diffuseColor.a * sys_DiffuseColor.a * alphaMask;
	
	
}